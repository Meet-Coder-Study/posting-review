# 좋은 테스트란 무엇일까? (in 이펙티브 유닛 테스팅)

![Effective Unit Testing](https://tva1.sinaimg.cn/mw1024/e6c9d24egy1h6a80jlwuwj208n0b4jrq.jpg)

안녕하세요. 렌입니다.

알면 좋고, 몰라도 되는 `좋은 테스트`에 대해서 이야기해볼까 합니다.

벌써 `좋은`  이라는 말에서 주관적이네요.

사실 좋은 테스트라는 것은 정답이 없습니다. 그러므로, `이펙티브유닛테스팅`  에서 말하는 좋은 테스트를 가져왔습니다.

읽는 이로 하여금 아닐 수도 있습니다. 그러나, 직접 테스트 코드를 작성하면서 이 책에서 말하는 좋은 테스트에 대해서 공감이 되는 부분이 너무 많았습니다.

이 책의 목표는 아래와 같습니다.
```
CHAPTER 2 좋은 테스트란?
_2.1 읽기 쉬운 코드가 유지보수도 쉽다
_2.2 구조화가 잘 되어 있다면 이해하기 쉽다
_2.3 엉뚱한 걸 검사하는 건 좋지 않다
_2.4 독립적인 테스트는 혼자서도 잘 실행된다
_2.5 믿음직한 테스트라야 기댈 수 있다
_2.6 모든 일이 그렇듯 테스트에도 도구가 쓰인다
```

여기서 저는 다음과 같은 주제를 이야기해보려 합니다.

_2.1 읽기 쉬운 코드가 유지보수도 쉽다.

_2.2 구조화가 잘 되어 있다면 이해하기 쉽다

_2.3 엉뚱한 걸 검사하는 건 좋지 않다

_2.4 독립적인 테스트는 혼자서도 잘 실행된다


**하나씩 천천히 이야기해볼까 합니다.**

##### 1. 읽기 쉬운 코드가 유지보수도 쉽다.

여기서 말하는 읽기 쉬운 코드란 어떤 코드를 말하는 걸까요? 우리 머리속에서는 가독성을 떠오르게 할 것입니다.

그럼 그 가독성은 어떻게 채울 수 있을까요? 가독성 높은 코드? 우리가 단어는 이해할 수 있지만 손은 이해할 수 없는 부분이 바로 **가독성 높은 코드** 라고 생각합니다.

가독성이라는 단어가 내포하고 있는 역할은 다음과 같을 것 같아요.

- 짫은 코드
- 의도가 드러난 변수명/함수명/클래스명 그 외
- 인터페이스을 활용한 명확한 메세지 전달 코드
- 형식(Given, When, Then) 지켜진 코드
- 군더더기가 없는 코드

가독성이 높은 코드를 작성한다는 관점에서는 이해되지만, 위에 언급된 역할을 지킬 수 있을까요?
```java
    @Test
    void notNull() {
        assertThat(sut).isNotNull();
    }

    @Test
    void refund() {
        RefundContext build = mock(RefundContext.class);

        given(finder.findByOrderId(ANY_ORDER_ID)).willReturn(build);
        given(build.refund(anyInt(), anyString())).willReturn(execution);

        sut.refund(ANY_ORDER_ID, REASON, 1000, new HashMap<>());

        verify(executor).execute(execution);

    }
```

위 코드는 제가 작성했었던 실제로 운영중인 서비스의 테스트 코드입니다.   
반성해야될 코드입니다. 그 이유는 테스트 코드가 존재할 의미가 없습니다.

`1. 읽기 쉬운 코드가 유지보수도 쉽다.` 를 찾아볼 수 있을까요?

불필요한 Mocking, 더군다나 Given, When, Then 도 명확하지 않네요. 그리고 가장 중요한 테스트 코드에 가독성이 없네요.

얼릉 이런 코드를 고쳐야겠습니다.

##### 2. 구조화가 잘 되어 있다면 이해하기 쉽다.

**구조화** 란 어떤 의미일까요? 좋은 테스트에서 구조화가 무슨 말이지? 하지 않나요? 이 또한 `빛좋은 개살구` 처럼 머리로는 이해되지만 코딩할 때의 제 손은 이해하지 못하는 부분인 것 같아요.

이 책에 나오는 다이어그램만큼은 꼭 소개하고 싶어서 직접 그려봤어요.

<img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=31604&x=-8874&y=24130&w=1628&h=661&store=1&accept=image%2F*&auth=LCA%2001226f627d4c14c0b532ca4fe1a2de958a9fdfbd-ts%3D1663439519" alt="img" style="zoom:50%;" />

왜 위 그림이 중요한지에 대해서 물어본다면 대답해주는게 인기상정!!

다이어그램을 천천히 따라가볼까요?

**코드가 구조화 되어 있지 않다.**  > **변경된 개념을 코드에 투영하기 어렵다.** > **사소한 변경이라도 악전고투를 유발한다.** > **아무도 손대려 하지 않는다.**  > ??

여기서  ?? 은  **작은 조각으로 나눈다.**

작은 조각으로 나누는게 무슨 의미가 있을까? 그럼 작은 조각이 구조화를 의미하는 걸까? 꼭 그렇지만은 않을 수 있습니다.

**작은 조각**으로 왜 나누는지에 대해서 고민해봤을까요? 작은 조각으로 나눈 이유는 경계를 명확하게 하기 위해서입니다.

프로덕트 코드를 이용하는 첫번째 클라이언트인 테스트 코드가 무엇을 테스트해야 하는지? 무엇을 의도하기 위한 용도인지 그 경계를 명확하게 하기 위해서라고 생각합니다.

*그 경계가 명확하지 않은 상태에서 무분별한 구조화는 차라리 하지 않느니만 못할 것입니다.*

##### 3. 엉뚱한 걸 검사하는 건 좋지 않다

이 책에서 소주제는 진짜 어그러를 잘 끌게 네이밍한게 아닐까 싶어요. 주제만 듣고도 벌써 공감의 마음이 샘솟으니까요.

이 주제에서 `엉뚱한 걸 검사한다`는 건 여러 의미가 있을 수 있지만, 제가 생각하는 `엉뚱한 걸 검사한다` 는 것은 테스트가 의도하고자 하는 메세지를 담지 못했다는 것입니다.

```java
    @Test
    void notNull() {
        assertThat(sut).isNull();
    }
// 음? notNull 인데, 테스트 코드에서는 isNull 이네...?
```

우리는 테스트 코드에 대해서(적어도 테스트 코드를 작성해야 한다고 믿는 사람들에게) 어느 정도의 신뢰를 가지고 있습니다.

분명 어떠한 테스트도 어떤 역할을 해주고 있을 것입니다. 하지만 그것이 전달되지 않는다면 무슨 의미가 있을까요?

>  이때 가끔은 테스트의 이름을 너무 믿어버리는 실수를 저지르곤 한다. 보통은 테스트의 이름을 보면 그 테스트가 검사하는 내용을 알 수 있는데, 실제로는 이름과 전혀 관련 없는 것을 검사하는 경우가 종종 있다.
>  - 이펙티브 유닛 테스팅 p50
>
> 올바른 것을 검사하는 것 못지않게 올바른 것을 똑바로 검사하는 것도 중요하다. 특히 유지보수 관점에서는 어떻게 구현했느냐가 아니라 의도한 대로 구현했느냐를 검사하는 게 중요하다.
>  - 이펙티브 유닛 테스팅 p51


##### 4. 독립적인 테스트는 혼자서도 잘 실행된다

분명 과거에는 알지 못했지만, 누군가의 액션에 의해서 `독립적인 테스트는 혼자서도 잘 실행된다` 에 대해서 깊이 공감할 수 있었습니다.

`테스트 코드가 독립적인 테스트가 될 것이라는 것은 당연한거 아니야?` 라 말할 수 있습니다.

근데요. 우리가 만드는 서비스에는 참 많은 의존성이 붙는 것 같습니다. 가장 흔하게 볼 수 있는 것이 바로 데이터베이스이구요, 좀 더 나아가면 AWS SQS,SNS 등의 특정 솔루션 등이 있습니다.

이런거 어떻게 테스트할 수 있을까요?

데이터베이스는 H2 데이터베이스로 하면 되지 않을까? 라고 생각하실 수 있습니다. 그것은 사실 감사하게도 우리가 사용하는 프레임워크(spring boot)의 도움이 있어서 가능했던 아니였을까?

만약 프레임워크가 없었다면 어떻게 테스트 할 수 있을까? 벌써부터 약간의 답답을 느끼지 않는가? 테스트할 때마다 DB를 켜놓을 것인가?

그 외에도 다음과 같은 의존성이 있을 수 있습니다.

- 시간
- 임의성
- 동시성
- 인프라
- 기존 데이터
- 영속성
- 네트워킹

위와 같은 것은 `우리가 제어할 수 없다`는 특징을 가집니다. 그러므로  독립적인 테스트를 만들기 어렵게 만드는 것입니다.

하지만, 이런 것을 피할 수 있는 도구를 만들거나, 서드파트를 활용해 **테스트가 격리와 독립성이 될 수 있도록 만들어야 합니다.**

---

# Mockito을  왜 쓰는지 모르겠다? (with. 테스트 더블)

안녕하세요. 렌입니다.

오늘은 우리가 테스트 코드 작성할 때마다 Mockito 을 사용하는데, `왜 사용하는지` 대해서 조금 더 깊게 이야기해볼까 합니다.

`테스트하고자 하는 객체의 의존성을 격리한다.` 라는 것이 우리가 흔히 아는 `왜 사용하는지`에 대한 답인데요.

여기서  Mocktio 는  `Test Double` 라는 큰 개념 안에 있는 하나입니다.

`Test Double`에 대해서 알게 된다면 Mocktio 을 왜 사용하는지 조금은 이해할 수 있지 않을까요?

> When we are writing a test in which we cannot (or chose not to) use a real depended-on component (DOC), we can replace it with a Test Double.
> The Test Double doesn’t have to behave exactly like the real DOC; it merely has to provide the same API as the real one so that the SUT thinks it is the real one!
> 테스트 코드를 작성할 때 실제 DOC(depoended-on component; 의존 구성 요소)를 사용할 수 없다면, DOC 대신 테스트 더블로 대체할 수 있음.
> 테스트 더블은 실제 DOC와 똑같이 행동하지 않아도 되며, 똑같은 API만 제공하면 된다.
>  - Gerard Meszaros

### Test Double 의 종류

어떤 `Test Double`이 있을까요? 흔히 4가지를 말합니다.

1. Stub
2. Fake
3. Spy
4. Mock

#### Stub

Stub 이라는 말을 어디서 들어봤을까요? Stub 의 뜻은 `끝이 잘렸거나 유난히 짫은 것` 이라는 의미를 가집니다.

**Stub 의 목적은 원래의 구현을 최대한 단순한 것으로 대체하는 것입니다.**  예를 들면, 어떤 객체의 기본값을 반환하는 등의 행위를 의미할 수 있습니다.

Stub 이란 **테스트 더블**은 최대한 단순하게 만들어 테스트 격리를 유도하거나 최소한의 행위만을 보장하는 객체을 의미하는 것이라 생각했습니다.

뒤에서 설명할 Fake, Mock 과 비슷하다고 생각할 수 있지만, 적어도 제가 생각하기에는 테스트가 가진 기능이 가장 없는 것이 바로 Stub이 아닐까 생각합니다.

만약 Stub 이 최소한의 기능을 가졌다면, 그것보다 좀 더 많은 기능(ex, 입력에 따라 다른 결과를 반환하는 것)이 필요하다면 Fake 을 고려할 수 있습니다.

#### Fake

Fake 는 앞서 설명한 것 처럼 Stub 보다는 조금 더 많은 기능을 가졌습니다.

**Fake 객체는 진짜 객체의 행동을 흉내내면서, 진짜 객체를 사용할 때 생기는 부수 효과나 연쇄동작이 일어나지 않도록 경량화하고 최적화한 것입니다.**

```java
interface UserRepository {
	void save(User user);
	User findById(long id);
	User findByUsername(String username);
}
```

위와 같은 인터페이스가 있다면, Stub 을 만들 수도 있지만 간단한 인메모리 데이터베이스를 만들어 사용할 수 있습니다.

```java
class FakeUserRepository implements UserRepository {
	private Collection<User> users = new ArrayList<User>();

	public void save(User user){
	...
	}
	... 중략
}
```

위와같이 사용하는데, 실제 객체를 사용하는 것보다 더 빠르게 동작할 뿐만 아니라, 테스트에서 DB의 의존성 또한 격리시키게 되었습니다.


#### Spy

> 테스트 스파이는 기밀을 훔친다. - p71 이펙티브유닛테스팅

왜 Spy 는 기밀을 훔칠까? Spy 는 Stub 이나, Fake 처럼 개발자가 임의로 만든 객체가 아닌 실제 객체를 사용합니다.

Spy 을 사용하는 이유는 단순합니다.

테스트 코드를 작성하다 보면 종종 void 을 반환하는 메서드를 어떻게 테스트해야 되지? 라는 생각을 하게 됩니다.

```java
public <T> void  filter(List<T> list, Predicate<T> predicate) {
        list = list.stream().filter(predicate).collect(Collectors.toList());
}
// filter 가 잘 동작됨을 어떻게 확인할 수 있지?
```

이럴 때 사용할 수 있는 Spy 입니다. 마치 잠복근무를 하는 경찰이 목격한 내용을 보고하는 것과 비슷합니다.

```java
@Test
    void name2() {

        List<String> strings = new SpyList<>();
        strings.add("A");
        strings.add("B");

        removefilter(strings, (t) -> t.equals("A"));
        assertThat(strings.has("A")).isFalse();
        assertThat(strings.has("B")).isTrue();
    }
```

Mocktio 에서는 @Spy 에 대한 구현이 있습니다.

테스트 스파이는 목격한 일을 기록해두었다가 나중에 테스트가 확인할 수 있게끔 만들어진 테스트더블입니다.

#### Mock

Spy 가 실제 객체를 활용해 기록했다가 테스트가 확인하는 용도라면, Mock 은 어떤 것이든 테스트가 원하는 것을 반환하도록 해주는 테스트 더블입니다.

특정 조건이 발생하면 미리 약속된 행동을 취합니다.



### 그렇다면 `Test Double`이 전달해주는 가치에 대해서 이야기해봅시다.

1. `테스트하고자 하는 객체의 의존성을 격리한다.`
2. `테스트의 속도를 더 빠르게!`
3. `예측 불가능한 실행 요소를 제거한다.`

#### 테스트하고자 하는 객체의 의존성을 격리한다.

격리를 한다는 것은 코드을 2가지로 분류할 수 있다는 이야기입니다.
- 테스트 대상 코드
- 테스트 대상 코드와 상호작용하는 코드

<img src="https://documents.lucid.app/documents/a6b2e07d-a201-4959-8dad-8c191ba78039/pages/0_0?a=34529&x=4631&y=9011&w=1087&h=638&store=1&accept=image%2F*&auth=LCA%20a9145129e9320e193ec75c59e4e4d3cf78ca5018-ts%3D1663810542" alt="img" style="zoom:50%;" />

테스트 대상 코드를 상호작용하는 코드로부터 의존성을 분리하는 것을 의미합니다.

분리함으로써,

**테스트는 초점이 분명해지고, 이해하기도 쉬워지며, 테스트 코드에 필요한 설정이 간편해집니다.**

#### 테스트의 속도를 더 빠르게!

위에서 언급한, Stub, Fake, Spy, Mock 등의 테스트 더블을 활용하게 된다면,

전에 계산해둔 경로를 반환하도록 하여 쓸데없이 기다리는 시간이 줄어들어 테스트 속도를 더 빠르게 개선할 수 있게 됩니다.

#### 예측 불가능한 실행 요소를 제거한다.

테스트 더블을 사용해야되는 이유는 무엇을 테스트하고 싶은 것인지 명확히 할 수 있다.

예를 들어, 현재 시간에 의존적인 테스트가 있다면 어떻게 테스트 할 것인가? 그런 부분을 테스트 더블을 활용해 격리하여

테스트하고자 하는 곳에 집중할 수 있게 됩니다.
