---
title: "'프로그래머의 뇌'를 읽고"
description: "'프로그래머의 뇌'를 읽고 정리한 이야기입니다."
date: '2023-06-14'
slug: 'the-programmers-brain'
thumbnail: './images/the-programmers-brain-thumbnail.png'
thumbnail_alt: 'the-programmers-brain-thumbnail'
category: 'reading'
---

# 프로그래머의 뇌

<Callout>
  💡 혼란과 인지적으로 압도당하는 느낌은 괜찮은 것이고, 우리 일상과 학습의 일부이다.
</Callout>

## 코드가 초래하는 세 가지 종류의 혼란

<Image
  src="https://raw.githubusercontent.com/jgjgill/blog/main/contents/reading/the-programmers-brain/images/cognitive-process.png"
  alt="cognitive-process"
/>

### 지식의 부족 (Knowledge)

지식이 없다는 것은 두뇌의 **장기 기억 공간**(Long Term Memory, LTM)에 해당 내용이 없다는 것이다.
LTM은 오랜 시간 동안 저장되는 특징이 있다.

다음 예시는 장기 기억 공간에 해당 내용이 없는 예시로 지식이 없는 경우를 잘 설명해준다.

**APL에서의 이진수 표현**

```APL
2 2 2 2 2 ⊤ 10
```

위의 코드를 봤을 때 이해가 안되는 이유는 APL을 모르고 `T`의 지식이 없기 때문이다.
따라서 `T`가 어떤 수의 값을 다른 진법의 수로 변환해준다는 것을 알면 코드를 이해하는 것이 쉬워진다.

### 정보의 부족 (Informantion)

정보가 부족하다는 것은 **단기 기억 공간**(Short Term Memory, STM)에 해당 내용이 없다는 것이다.
STM은 들어오는 정보를 잠시 보관하기 위해 사용된다.

다음 예시는 단기 기억 공간에 대해서 설명한다.

**자바에서의 이진수 표현**

```java
public class BinaryCalculator {
  public static void mian(Integer n) {
    System.out.println(Integer.toBinaryString(n))
  }
}
```

자바에 대해서 잘 알지 못해도 어느 정도 이름을 통해 유추할 수 있다.
구체적으로 알기 위해서는 메서드의 내부를 살펴보는 단계가 필요한데, 위의 예제에서는 `toBinaryString`이 해당된다.
이때 발생하는 혼란은 정보가 부족하기 때문에 발생하는 것이다.

이 예제에서 재밌었던 것은 `main`을 `mian`으로 의도적으로 바꾼 것이다.
아마 코드를 읽을 때 대부분 `main`으로 읽거나 별다른 생각을 가지지 않았을 것이다.
이 부분이 나한테는 **인지 부하**, **청크** 등의 중요성을 잘 느끼게 해주었다.

### 능력의 부족 (Processing Power)

능력의 부족은 처리 능력의 부족을 의미한다.
이는 **작업 기억 공간**(working memory)에 해당하며 작업 기억 공간은 사고할 때 사용된다.
책에서는 다음 예시를 통해 설명한다.

**베이직에서의 이진수 표현**

```basic
LET N2 = ABS(INT(N))
LET B$ = ""
FOR N1 = N2 TO 0 STEP 0
  LET N2 = INT(N1 / 2)
  LET B$ = STR$(N1 - N2 * 2) + B$
  LET N1 = N2
NEXT N1
PRINT B$
```

위의 코드는 변수 이름이나 연산자 등이 있지만,
앞서 살펴본 자바 코드와 비교했을 때 한눈에 파악할 수 없다.
모든 단계를 이해하려면 코드를 하나씩 파악하는 과정이 필요할 것이다.
이러한 혼란이 처리 능력 부족으로 발생하는 것이다.

## 어떻게 해야 코드를 더 잘 읽을 수 있을까?

### 코드 읽기

코드를 읽는 연습의 중요성을 말한다.

> 프로그래머의 시간 중 대부분은 코드를 '작성'하는 것이 아닌 '이해'하는데 사용한다.

> 프로그램은 사람이 읽을 수 있도록 작성해야만 한다.
> 기계가 실행하는 것은 부차적인 일이다.

> 산술 능력은 프로그래밍 능력에 대해 예측력이 별로 없다.
> 언어 능력이 훨씬 더 예측력이 크다.

**텍스트를 읽는 것과 코드를 읽는 것은 유사**하다.
코드를 빠르게 읽어나가고 이해하기 위해 노력하자.

### 청크의 중요성

코드를 읽을 때 혼란을 줄이기 위해서는 기억의 크기 제한을 넓혀야 한다.
이를 위해서는 기억하는 대상이 아닌 **기억하는 방식**을 중요하게 생각해야 한다.
다음 예시는 단위로 묶는, **청크**의 힘을 경험할 수 있게 해준다.

> 다음 문장을 5초간 본 후 어떤 문장인지 기억해보자.

```
abc martpi gbar
```

> 이전과 똑같이 다음 문장을 5초간 본 후 어떤 문장인지 기억해보자.

```
cat loves cake
```

후자의 문장이 훨씬 기억하기 쉽다.
이는 코드에서도 동일하다.
청크로 묶인 코드들로 더 빠르게 코드를 읽어나가고 이해할 수 있다.

따라서 청킹 연습으로 **적극적으로 코드를 기억하는 훈련**을 할 필요가 있다.
청크 이외에도 책에서는 디자인 패턴, 표식(beacon)을 권장한다.

## 문법 빠르게 기억하며 배우기

### 어떻게 하면 잊어버리지 않을 수 있을까?

- 오랫동안 학습한 만큼 더 오래 기억한디.
- 오랜 간격을 두고 학습해야 한다.
- 정기적으로 꾸준히 연습한다. 반복할 때마다 기억은 강화된다.

이 부분은 어찌보면 당연한 이야기일 것이다.

### 능동적으로 기억하기

중요하게 느껴진 부분은 **능동적으로 기억하기**이다.
LTM로부터 기억을 가져오는 두 가지 기제로 **저장 강도**와 **인출 강도**로 구분한다.
저장 강도는 '무언가를 LTM에 얼마나 잘 저장하고 있는가'를 의미하고,
인출 강도는 '무언가를 얼마나 쉽게 기억하는가'를 의미한다.
답이 입에서 맴돌기만 하고 기억이 나지 않는 것은 저장 강도는 높지만 인출 강도는 낮다는 것을 의미한다.

따라서 내가 머릿 속에서만 안다고 생각하는 것에 속으면 안된다.
**인출 연습**을 할 필요가 있다.
검색에만 의존하면 단순히 보는 것에만 그치기 쉽기 때문에 검색 이전에 적극적으로 무언가를 일부러 기억해보려고 애쓰는 습관을 가져보자.

## 복잡한 코드 읽는 방법

### 인지 부하 줄이기

복잡한 코드가 이해하기 어려운 이유는 **인지 부하** 때문이다.
부하는 문제 자체의 복잡성 때문일 수도 있고 언어가 낮선 탓에 청크의 양이 적어 문제가 발생할 수도 있다.

이에 이를 자신이 잘 인지하여 **리팩토링**을 통해 **가독성**을 높이거나 생소한 언어는 익숙한 것으로 대치하여 **청크**의 양을 늘릴 수 있도록 하자.
혹은 노트나 주석 등 **기억 보조 수단**을 활용해도 나쁘지 않다.

### 자동화: 암시적 기억 생성

문제를 해결할 때 **순간적인 기억력**에 크게 의존한다.
어떤 의미에서는 익숙한 문제를 해결하기 보다는 **재현**한다.
이전에 유사한 문제에 효과가 있었던 해결책에 의존하는 것이다.

이에 암시적 기억, 즉 직감을 어떻게 훈련할 수 있을까?

암시적 기억은 **반복과 연습**을 통해 생성된다.
다음 세 단계로 이루어진다.

- 인지 단계: 무언가 새로운 것을 배우는 때
- 연상 단계: 응답 패턴이 나타날 때까지 새 정보를 적극적으로 반복하는 단계(효과적인 조치 기억, 효과적이지 않는 조치 폐기)
- 자율 단계: 자동화 가능으로 아무런 노력없이 일 수행 가능, 인지 부하 증가x

**의도적 연습**을 반복적으로 실행하자.

### 코드와 해설에서 배우기

단순히 프로그래밍을 많이 한다고 문제 해결을 더 잘하게 되는 것은 아니다.
다른 사람들이 문제를 어떻게 해결했는지 의도적으로 연구하는 것이 필요하다.
이러한 해결책을 **풀이된 예제**라고 부른다.

## 마무리

복잡하고 낯선 코드에 압도되어 자신을 자책하거나 좌절하지 말고 관대하게 뇌가 너무 큰 인지 부하를 겪고 있다고 생각하자.😚
