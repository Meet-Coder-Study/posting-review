# 분산 메시지 큐

- [가상 면접 사례로 배우는 대규모 시스템 설계 기초2 - 4장 분산 메시지 큐 정리](https://github.com/SeokRae/202410_blog_13/issues/3)

## 분산 메시지 큐

분산 메시지 큐라는걸 왜 사용해야하지?

1. 대규모 트래픽 처리가 필요한 경우
2. 비동기 처리가 필요한 경우
3. 서비스 간 결합도를 낮춰야 하는 경우
4. 신뢰성 있는 메시지 전달이 필요한 경우
5. 장애 복구와 재시도 로직이 필요한 경우
6. 부하 분산 및 처리량 증가가 필요한 경우

### 메시지 큐란?

메시지 큐는 일대일 메시지 전달, 비동기 통신, 순서 보장, 단기 보관 등의 특징을 가지며, 단순하고 신뢰성 있는 메시지 전송에 중점을 둔 시스템입니다. 빠르게 메시지를 전달하고 처리할 수 있는 환경에서 유용하게 활용됩니다.

1. 일대일 메시지 전달 (Point-to-Point)
2. 비동기 통신
3. 신뢰성 있는 메시지 전송
4. 순서 보장
5. 단기 데이터 보관
6. 전송 방식 선택 (At-Least-Once, At-Most-Once, Exactly-Once)
7. 확장성

#### 메시징 모델 구분

- Message Queue

![메시지 큐](https://github.com/user-attachments/assets/64f8102b-377e-48c1-8b88-c1da3678d05b)

- pub/sub pattern

![CleanShot 2024-10-29 at 14 42 08@2x](https://github.com/user-attachments/assets/8ac8a5e2-6ab5-4fac-829c-090793d9e2ba)

### **이벤트 스트리밍 플랫폼**이란?

이벤트 스트리밍 플랫폼은 실시간 데이터 처리, 안정적인 데이터 보존, 내결함성, 데이터 복제 등의 매커니즘을 통해, 다양한 시스템에서 발생하는 이벤트를 빠르고 효율적으로 수집하고 처리할 수 있는 환경을 제공합니다. 이를 통해 대규모 데이터가 발생하는 환경에서 실시간 분석, 모니터링, 자동화된 응답 등이 가능해집니다.

1. 데이터 스트림 수집 (Ingestion)
2. 토픽 기반 분류 (Topic-based Categorization)
3. 데이터 저장 및 보존 (Data Storage and Retention)
4. 실시간 데이터 처리 (Real-time Data Processing)
5. 구독 기반 데이터 소비 (Subscription-based Consumption)
6. 데이터 복제 및 장애 복구 (Data Replication and Fault Tolerance)
7. 데이터 일관성과 전달 보장 (Data Consistency and Delivery Guarantees)

![CleanShot 2024-10-30 at 20 36 52](https://github.com/user-attachments/assets/36f407d3-77c1-420f-a0de-6bdcd89bfcf5)

### 주요 차이점

메시지 큐와 이벤트 스트리밍 플랫폼이라는 주요기능 차이 및 매커니즘 차이가 있기 때문에 이를 이해해야 적합한 상황에서 사용할 수 있습니다.

1. 데이터 전달 방식

  - 메시지 큐: 보통 일대일(Point-to-Point) 방식으로 동작하여 하나의 메시지는 하나의 소비자에게만 전달됩니다. 메시지를 소비자가 처리하면 큐에서 삭제되어, `재처리가 어렵습니다.`
  - 이벤트 스트리밍 플랫폼: 발행-구독(Publish-Subscribe) 방식으로 여러 소비자가 동시에 동일한 메시지를 구독할 수 있습니다. 데이터는 로그에 쌓여 남아있기 때문에, 여러 소비자가 `동시에 읽거나` 나중에 `재처리할 수 있습니다.`

2. 데이터 보존 및 재처리

  - 메시지 큐: 메시지가 소비된 후 삭제되며, 과거 데이터에 접근하거나 재처리 할 수 없습니다. 즉, 메시지를 일회성으로 빠르게 전달하는 데 초점을 맞춥니다.
  - 이벤트 스트리밍 플랫폼: 데이터가 로그에 영구적으로 저장되며, 과거 데이터를 필요할 때 재처리하거나 분석할 수 있습니다. 따라서 실시간 분석이나 로그 보관이 필요한 시스템에 유리합니다.

3. 확장성

  - 메시지 큐: 일반적으로 중앙 서버에서 실행되며, 확장성이 제한적입니다. 대규모 시스템에서는 큐의 성능이 제한될 수 있습니다.
  - 이벤트 스트리밍 플랫폼: 분산 시스템으로 설계되어 대규모 확장이 가능합니다. 데이터가 여러 노드에 분산 저장되어 병렬 처리에 유리합니다.

4. 주요 사용 사례

  - 메시지 큐: 짧은 시간 동안 메시지를 유지하고, 일시적 데이터 전송이 필요한 경우에 사용됩니다. 예를 들어, 간단한 작업 큐, 주문 처리 시스템 등에서 사용됩니다.
  - 이벤트 스트리밍 플랫폼: 장기적인 데이터 보존, 실시간 데이터 분석, 로그 수집 등 지속적인 데이터 스트리밍이 필요한 경우에 적합합니다. 예를 들어, 실시간 사용자 행동 분석, IoT 데이터 수집 및 처리에 사용됩니다.

5. 내구성 및 데이터 복제

  - 메시지 큐: 일부 메시지는 메모리에 보관되거나 짧은 시간 동안만 보존되므로, 내구성이 다소 낮고 `장애 시 데이터 손실이 발생`할 수 있습니다.
  - 이벤트 스트리밍 플랫폼: 데이터를 디스크에 저장하고 여러 노드에 복제하여 `내구성`과 `데이터 보존이 보장`됩니다. 장애 발생 시에도 데이터 `손실 위험이 낮습니다.`


---

### 첫 번째 단계: 문제 이해 및 설계 범위 확정

1. **메시지의 형식과 크기**: 텍스트 형식의 메시지만 지원하며, 메시지의 크기는 수 킬로바이트(KB) 수준으로 제한.
2. **메시지 반복 소비 가능 여부**: 하나의 메시지를 여러 소비자가 반복적으로 소비할 수 있도록 지원.
3. **메시지 순차적 전달**: 메시지는 생산된 순서대로 소비되어야 하며, 순차적 소비는 필수적인 요구사항.
4. **데이터 지속성**: 메시지는 최대 2주간 보관되어야 하며, 필요 시 보관 기간을 조정할 수 있도록 설정 가능.
5. **생산자와 소비자의 수**: 다수의 생산자와 소비자가 확장성 있게 시스템을 사용할 수 있도록 설계되어야 함.
6. **메시지 전송 보장 방식**: 정확히 한 번 전송(Exactly-once) 방식은 필수로 지원되어야 하며, 필요에 따라 최소 한 번 전송(At-least-once) 및 최대 한 번 전송(At-most-once) 방식도 선택적으로 지원 가능해야 함.
7. **대역폭과 지연 시간**: **높은 처리량(throughput)** 을 지원하면서도 **낮은 지연 시간(latency)** 을 유지해야 함.

#### 기능 요구사항

1. 생산자는 메시지를 큐에 `보낼 수 있어야(publish)` 한다.
2. 소비자는 메시지를 큐로부터 `가져갈 수(consume, subscribe, polling)` 있어야 한다.
3. 메시지 소비 방식(Message Consumption Guarantee)은 `반복적으로 소비(At-Least-Once)`될 수 있어야 하고, `한 번만 소비(Exactly-One)`되도록 설정할 수 있어야 한다.
4. 오래된 데이터는 삭제될 수 있어야 한다. (데이터 보관 정책이 존재)
5. 메시지 크기는 킬로바이트 수준이어야 한다. (성능 최적화)
6. 메시지가 생산된 순서대로 소비자에게 전달될 수 있어야 한다. (다양한 처리방식 존재)
7. 메시지 전달 방식(Message Delivery Guarantee)은 `최소 한 번(At-Least-Once Delivery)`, `최대 한 번(At-Most-Once Delivery)`, `정확히 한 번(Exactly-Once Delivery)` 중 선택할 수 있어야 한다.

#### 비기능적 요구사항

- 높은 대역폭과 낮은 지연 시간을 선택적으로 설정할 수 있어야 한다: 메시지 큐는 높은 처리량을 제공하면서도 낮은 지연 시간을 지원할 수 있어야 합니다.
- 확장성: 시스템은 메시지 양이 급격히 증가해도 확장 가능하도록 설계되어야 합니다.
- 지속성 및 내구성: 데이터는 디스크에 지속적으로 저장되어야 하며, 여러 노드에 복제되어 안정성을 보장해야 합니다.

---

### 두 번째 단계: 개략적 설계안 제시 및 동의 구하기

1. 메시지 큐의 기본 구성

    - 생산자(Producer)는 메시지를 큐에 발행합니다.
    - 소비자(Consumer)는 큐에 구독(Subscribe)하여 큐에 쌓인 메시지를 소비합니다.
    - 메시지 큐는 생산자와 소비자가 독립적으로 운영될 수 있게 하며, 각 컴포넌트가 서로 확장 가능하게 구성됩니다.

2. 생산자와 소비자의 관계

    - 생산자와 소비자는 클라이언트-서버 모델을 따르며, 메시지 큐는 이 클라이언트들 사이의 네트워크 통신을 담당합니다. 이를 통해 메시지를 주고받으며 비동기적으로 처리할 수 있습니다.

#### 메시지 모델

요구사항에 맞는 메시지 모델을 찾기 위해서 아래 두 가지 메시지 모델의 특징과 차이점을 이해하고, 보다 알맞은 모델을 찾아갈 수 있도록 합니다.

1. 일대일(Point-to-Point) 모델
    - 이 모델은 메시지를 생산자가 큐에 넣으면 오직 하나의 소비자만 그 메시지를 받아 처리하는 방식입니다. 
    - 메시지가 처리되면 큐에서 삭제됩니다. 이 방식은 하나의 작업을 딱 한 명의 소비자만 처리해야 할 때 적합합니다. 
    - `이 모델은 메시지를 저장하거나 여러 소비자에게 동시에 보내는 기능을 기본적으로 제공하지 않습니다.`

![CleanShot 2024-11-06 at 15 19 11@2x](https://github.com/user-attachments/assets/9a3dc648-4cdf-4c98-833c-d2839f7dd248)

2. 발행-구독(Pub-Sub) 모델
    - 이 모델에서는 “토픽(topic)“이라는 개념이 사용됩니다. 
    - 생산자가 토픽에 메시지를 발행하면, 그 토픽을 구독한 여러 소비자가 동시에 그 메시지를 받을 수 있습니다. 
    - 즉, 하나의 메시지가 여러 소비자에게 동시에 전달되는 방식입니다. 
    - 메시지를 특정 주제별로 나눠서 다수의 소비자가 각자 필요한 메시지를 받을 수 있도록 하는 데 유용합니다.

![CleanShot 2024-11-06 at 15 26 00@2x](https://github.com/user-attachments/assets/dc9410ed-9a79-4754-a601-e3b065f8edf8)

** 발행-구독 모델이 메시지를 반복적으로 소비할 수 있어야 한다는 요구사항에 알맞기 때문에 선택가능

#### 토픽, 파티션, 브로커

메시지 모델을 더욱 세분화하고 확장성, 신뢰성, 성능을 제공하기 위한 구성요소로 소개됩니다.

1. 토픽(Topic)

    - 토픽은 메시지가 저장되는 논리적인 단위입니다. 
    - 발행-구독 모델의 기반이 되어, 특정 주제나 카테고리로 메시지를 분류하고 관리할 수 있도록 해줍니다.

2. 파티션 (Partition)

    - 토픽의 데이터를 분할하여 관리하는 방식입니다.
    - 메시지를 여러 파티션으로 분산하여 병렬 처리를 가능하게 하고, 처리 성능을 높입니다. 이는 대규모 발행-구독 모델에서 중요한 역할을 합니다.

3. 브로커(Broker)

    - 브로커는 토픽과 파티션을 관리하며, 메시지를 생산자에게서 받아서 저장하고, 이를 소비자에게 전달하는 역할을 합니다. 
    - 토픽과 파티션을 관리하고, 메시지를 소비자에게 전달하는 역할을 하여 메시지 시스템의 신뢰성과 확장성을 지원합니다.

> 메시지 모델에 따라 토픽, 파티션, 브로커의 동작방식이 달라진다.

- 발행-구독 모델에서는 여러 소비자가 하나의 토픽을 동시에 구독할 수 있어야 하므로 토픽과 파티션을 통해 메시지의 병렬 처리를 지원하고, 브로커를 통해 메시지를 관리하고 분산합니다.
- 일대일 모델에서는 메시지가 하나의 소비자에게만 전달될 수 있도록 파티션과 소비자 그룹을 구성하여 순서와 독점적인 소비를 보장합니다.

#### 소비자 그룹

토픽, 파티션, 브로커가 제공하는 확장성과 데이터 분산 구조 위에서 소비자 그룹은 병렬 처리와 확장성을 극대화하는 마지막 요소입니다.

소비자 그룹은 위 토픽과 파티션 위에 동작하기 때문에, 이 세 가지 요소(토픽, 파티션, 브로커)를 이해하는 것이 소비자 그룹의 역할과 동작 방식을 이해하기 위한 기초가 됩니다.

파티션 기반 분산 처리 개념을 먼저 이해하면 소비자 그룹의 필요성이 명확해집니다. 각 파티션은 메시지 순서를 보장하는데, 소비자 그룹은 여러 소비자가 파티션을 병렬로 처리하도록 구성하여 처리량을 높이는 역할을 합니다.

브로커가 파티션과 소비자 그룹 간의 상호작용을 관리하여 각 소비자가 적절한 파티션을 할당받고 순서를 유지할 수 있도록 조율하기 때문에, 소비자 그룹을 이해하려면 이 관계가 먼저 설명되어야 합니다.

1. 소비자 그룹의 역할
2. 순서 보장 문제
3. 처리량(Throughput)과 확장성
4. 오프셋 관리
5. 일대일 모델과 발행-구독 모델의 지원

#### 개략적 설계안

![CleanShot 2024-11-07 at 21 15 52](https://github.com/user-attachments/assets/51a7107f-1fb7-4c83-a71a-18e5f4a88f8c)

1. 생산자 (Producer)
    - 생산자는 메시지를 특정 토픽으로 전송하는 역할을 합니다. 이 메시지는 브로커로 전달되어 저장됩니다.

2. 브로커 (Broker)
    - 브로커는 메시지를 큐(파티션)에 저장하고 관리하는 핵심 역할을 합니다. 브로커는 데이터를 여러 파티션에 분배하며, 그 과정에서 메시지를 유지하고 전달하는 역할을 담당합니다.

3. 저장소 (Storage)
    - 데이터 저장소: 메시지가 파티션 내 데이터 저장소에 보관됩니다.
    - 상태 저장소: 소비자 상태나 메시지 처리 상태가 이 저장소에 기록됩니다.
    - 메타데이터 저장소: 토픽 설정, 속성 등의 메타데이터가 저장됩니다. 이 저장소는 토픽의 관리 및 설정에 필요한 정보를 담고 있습니다.

4. 소비자 (Consumer)
    - 메시지를 소비하는 주체로, 소비자 그룹으로 구성됩니다. 각 소비자는 자신이 구독한 토픽에서 메시지를 가져가서 처리합니다.

5. 조정 서비스 (Coordination Service):
    - 서비스 탐색 (Service Discovery): 어떤 브로커가 활성 상태인지 탐색하고 알려줍니다.
    - 리더 선출 (Leader Election): 브로커 클러스터에서 하나의 브로커가 리더로 선출되어 컨트롤러 역할을 수행합니다. 클러스터 내에서 반드시 하나의 컨트롤러가 활성 상태로 존재해야 하며, 해당 컨트롤러는 파티션 배치를 담당합니다.
    - Apache ZooKeeper 또는 etcd: 리더 선출과 같은 조정 역할을 수행하는 도구로 사용됩니다.

> 조정 서비스 내용에서 카프카 버전 3.3 이후 카프카는 ZooKeeper 대신 KafkaCluster에서 Raft Consensus 알고리즘을 통해 Leader Election을 진행

- [What’s New in Apache Kafka 3.3](https://www.confluent.io/ko-kr/blog/apache-kafka-3-3-0-new-features-and-updates/)
- [The Raft Consensus Algorithm](https://raft.github.io)
- [Raft Consensus 시각화](http://thesecretlivesofdata.com/raft/)

---

### 세 번째 단계: 상세 설계

시스템이 대량의 데이터를 장기적으로 보관해야 하는 상황과 높은 대역폭에 대한 요구사항을 직면하는 경우, 어떻게 해결할 수 있을까?

> 예를 들면, "메시징 시스템이 수백만 개의 메시지를 안정적으로 전송하고, 데이터가 손실되지 않도록 영구적으로 저장해야 한다면?"

첫 번째로 "디스크 성능 최적화를 위한 순차 처리와 캐싱 전략"을 고민해볼 수 있습니다.

두 번째로 "메시지의 무결성을 유지하는 구조 설계"에 대해서 고민해볼 수 있습니다.

세 번째로 "효율적인 전송을 위한 일괄 처리 시스템 도입"에 대해 고민해볼 수 있습니다.

#### 데이터 저장소 설계

메시지를 어떻게 지속적으로 저장할 지를 고민해보기 위해 메시지 큐의 트래픽 패턴을 살펴봅니다.

메시지 큐는 읽기보다는 쓰기 작업이 빈번하게 발생합니다. 일반적으로 메시지는 한 번 쓰여진 후 변경되지 않으며, 대부분은 빠르게 소비될 수 있는 구조입니다.

메시지를 어떻게 지속적으로 저장할 것 인가에 대한 방안을 상세히 설명하고 있습니다. 메시지 큐의 트래픽 패턴을 고려하여 데이터 저장소를 선택하는 것이 중요하며, 여기에는 다음과 같은 주요 고려 사항들이 있습니다.
이러한 쓰기 중심의 패턴에서, 특정한 경우를 제외하고는 메시지를 수정하지 않고 전송할 수 있도록 설계하여 성능을 최적화할 수 있습니다.

1. 트랜잭션 데이터베이스를 사용하는 방식
2. NoSQL 데이터베이스를 사용하는 방식
3. 쓰기 우선 로그 (WAL: Write-Ahead Log)를 사용하는 방식
4. 파일 기반의 데이터 저장소 (세그먼트와 파티션을 활용한 방식)

#### 메시지 자료 구조

메시지 자료 구조는 생산자와 소비자 사이의 계약(Contract) 역할을 하며, 높은 대역폭을 달성하고 효율적인 데이터 전송을 위해 중요한 부분입니다. 
메시지가 큐를 통해 전달될 때 **불필요한 복사(copy)**가 발생하지 않도록 설계하는 것이 핵심입니다. 
만약 메시지가 제대로 전달되지 않으면 변경 과정에서 복사가 발생해 시스템 전체 성능이 떨어질 수 있습니다.

자료구조의 각 요소를 이해하면 메시지 처리 성능을 최적화하고, 데이터 일관성과 무결성을 보장할 수 있습니다.

1. 메시지 키 (Message Key)
2. 메시지 값 (Message Value)
3. 메시지의 기타 필드

#### 일괄 처리

일괄 처리는 분산 메시지 큐의 성능을 향상시키기 위해 주로 사용됩니다. 메시지를 묶어서 처리함으로써 시스템은 네트워크 호출과 디스크 I/O 오버헤드를 줄일 수 있으며, 이를 통해 처리량을 높이고 자원 사용을 줄일 수 있습니다.

1. 시스템 효율성
2. 메시지 지연(latency)
3. 데이터 구조 및 구성
4. 네트워크 및 디스크 I/O 감소
5. 복제 및 중복성

분산 메시지 큐의 일괄 처리는 시스템 효율성을 높이기 위해 메시지를 그룹화하여 네트워크 및 디스크 I/O 작업을 줄이는 것을 목표로 합니다. 
이를 통해 처리량을 늘리는 동시에 메시지 지연 시간이 다소 증가할 수 있으며, 최적의 성능을 위해 배치 크기와 데이터 저장 메커니즘을 적절하게 구성하는 것이 중요합니다.

#### 생산자 측 메시지 전송 흐름에 대한 전략

분산 메시지 플랫폼에서 생산자 측 메시지 전송은 단순한 데이터 전달을 넘어, 시스템의 안정성과 성능을 결정짓는 중요한 요소입니다. 
특히, 메시지가 다양한 노드와 네트워크를 통해 분산되는 과정에서 발생할 수 있는 데이터 불일치와 성능 저하를 최소화하는 것이 핵심 과제입니다. 이를 해결하기 위해 분산 시스템에서는 생산자가 메시지를 효율적이고 신뢰성 있게 전송할 수 있는 다양한 전략을 채택합니다.

1. 라우팅 레이어 도입
2. 복제 계획 및 저장
3. 리더-팔로워 구조
4. 네트워크 효율성 

#### 소비자 측 메시지 처리 흐름

분산 메시지 큐 시스템에서 소비자 측 메시지 처리 흐름은 데이터를 안정적이고 일관성 있게 전달받기 위해 매우 중요한 역할을 합니다. 
생산자와 브로커가 메시지를 생성하고 전달하는 과정이 원활하게 이루어지더라도, 소비자가 이를 효율적이고 신뢰성 있게 처리하지 못하면 전체 시스템의 안정성이 위협받을 수 있습니다. 
특히, 메시지의 순서 보장, 데이터 중복 방지, 장애 상황에서의 복구 가능성 등은 분산 시스템의 성능과 사용자 경험을 좌우하는 핵심 요소입니다.

1. 오프셋 관리
2. 푸시 vs 풀 모델
3. 소비자 재조정(Consumer Rebalancing)
4. 상태 저장(State Storage)

#### 푸시(Push) vs 풀(pull) 모델

분산 메시지 큐 시스템에서 푸시(Push)와 풀(Pull) 모델은 소비자 측의 메시지 처리 방식에 중요한 영향을 미치는 두 가지 주요 전략입니다. 
푸시 모델은 브로커가 메시지를 적극적으로 소비자에게 전달하는 방식이고, 풀 모델은 소비자가 필요한 시점에 메시지를 요청하는 방식입니다. 
이 두 가지 접근 방식은 시스템의 성능, 데이터 일관성, 리소스 관리 등 다양한 측면에서 차별화된 장단점을 가지고 있으며, 시스템 요구사항에 따라 적절한 모델을 선택하는 것이 중요합니다.

1. 푸시 모델
2. 풀 모델

- [kafka - Push vs Pull](https://kafka.apache.org/documentation/#design_pull)


#### 소비자 재조정(Consumer Rebalancing)

분산 메시지 큐 시스템에서 소비자 재조정은 새로운 소비자가 그룹에 참여하거나 기존 소비자가 그룹을 떠날 때, 각 파티션의 담당 소비자를 다시 설정하는 과정입니다. 이 과정은 데이터의 일관성을 유지하고 시스템 가용성을 높이기 위해 필수적입니다. 
소비자 그룹의 구성원이 동적으로 변할 수 있는 분산 시스템에서는 재조정을 통해 각 파티션의 메시지 처리가 중단 없이 이어질 수 있도록 보장해야 합니다.

1. 재조정 프로세스
2. 리더 선출과 파티션 분배 계획 수립
3. 네트워크 장애 대응
4. 효율적인 상태 저장


#### 상태 저장소

분산 메시지 큐 시스템에서 상태 저장소는 각 메시지의 처리 상태를 추적하고 데이터의 일관성을 유지하는 중요한 역할을 합니다. 
분산 환경에서는 메시지가 여러 파티션과 노드에 분산되기 때문에, 각 메시지의 처리 상태와 위치를 기록하는 저장소가 필요합니다. 
이를 통해 시스템 장애나 재조정이 발생하더라도 메시지의 상태를 복원하고 연속적으로 처리할 수 있습니다.

1. 메시지 큐 시스템에서 상태 저장소의 역할과 필요성
2. 분산 메시지 큐에서 파티션별 오프셋 관리와 상태 저장소의 중요성
3. 분산 환경에서 메시지 상태 추적을 위한 상태 저장소 설계
4. 메시지 큐의 일관성을 유지하기 위한 상태 저장소와 메타데이터 관리
5. Kafka와 ZooKeeper를 활용한 메시지 상태 저장소의 구현 및 관리

#### 매타 저장소

메타저장소는 분산 메시지 큐 시스템에서 파티션 설정 정보와 메시지 보존 기간 같은 메타데이터를 관리하는 핵심 구성 요소입니다. 
이러한 메타데이터는 메시지 큐의 파티션 구조와 메시지의 수명을 정의하며, 시스템의 안정적인 운영을 지원합니다. 
특히, 카프카(Kafka)와 같은 시스템에서는 메타저장소를 통해 각 파티션과 오프셋 상태를 추적하여 일관성과 신뢰성을 유지합니다.

1. 분산 메시지 큐의 파티션 관리와 메시지 보존을 위한 메타저장소 역할
2. Kafka에서 ZooKeeper를 활용한 메타데이터 관리와 파티션 설정
3. 메타저장소: 분산 메시지 시스템에서 파티션 설정과 메시지 보존 기간 관리
4. 메시지 큐 시스템에서 메타저장소를 통한 파티션 정보와 오프셋 상태 추적
5. Kafka의 메타데이터 저장 방식: ZooKeeper를 활용한 파티션 및 오프셋 관리


#### 주키퍼(ZooKeeper)의 역할

주키퍼는 분산 시스템에서 메타데이터 관리와 동기화 서비스를 제공하는 계층적 키-값 저장소입니다. 
주로 분산 메시지 큐 시스템에서 파티션 정보, 리더 선출, 동기화 관리 등을 담당하여 시스템의 안정성을 높이는 중요한 역할을 합니다. 
Kafka와 같은 분산 시스템에서 주키퍼는 클러스터의 일관성과 가용성을 유지하는 데 필수적인 구성 요소입니다.

1. 메타데이터 및 상태 정보 저장소로서의 주키퍼 역할
2. Kafka 클러스터의 리더 선출 프로세스 관리
3. 분산 환경에서 데이터 일관성 유지를 위한 동기화 서비스
4. 명명 서비스(Naming Registry)를 통한 노드 관리
5. 장애 상황에서 데이터 일관성 보장을 위한 동기화 프로토콜


#### 복제(Replication)의 역할과 중요성

분산 메시지 큐 시스템에서 **복제(Replication)**는 데이터의 고가용성과 내구성을 보장하기 위한 필수적인 메커니즘입니다. 복제는 하나의 데이터를 여러 노드에 복사하여 저장함으로써, 특정 노드에 장애가 발생해도 데이터가 손실되지 않고 지속적으로 접근할 수 있도록 합니다. Kafka와 같은 시스템에서는 복제를 통해 데이터의 안정성과 연속성을 강화합니다.


1. 파티션 리플리카 분산 계획(Replica Distribution Plan)과 리더-팔로워 구조
2. 동기화된 사본(ISR, In-Sync Replica) 관리 및 데이터 일관성 유지
3. 장애 상황에서 고가용성 보장을 위한 리플리카 구조
4. 리플리카 일관성 설정을 통한 데이터 지연 관리
5. 복제에 따른 성능 영향과 시스템 부하 관리 전략

#### 사본 동기화(In-Sync Replica, ISR)의 역할과 중요성

사본 동기화는 분산 메시지 큐 시스템에서 데이터의 일관성과 내구성을 보장하기 위해 사용됩니다. 
ISR(In-Sync Replica)은 리더 리플리카와 데이터 동기화 상태에 있는 리플리카들로 구성되어 있으며, 모든 메시지에 대해 일관된 복제본을 유지합니다. 이를 통해 시스템 장애 시에도 데이터의 안전한 복구가 가능해집니다.

1. ISR(In-Sync Replica)의 정의와 리더-팔로워 구성 관리
2. 동기화 기준 설정을 통한 ISR 포함 여부 결정
3. 합의된 오프셋(committed offset) 관리로 데이터 일관성 보장
4. 내구성(durability) 보장을 위한 ISR 기반 ACK 관리
5. ACK 설정을 통한 성능 최적화와 내구성 균형 조정

#### 규모 확장성의 필요성

분산 메시지 큐 시스템은 대규모 데이터 처리와 안정적인 메시지 전달을 지원하기 위해 설계됩니다. 
특히 트래픽이 증가하고 메시지의 양이 많아질수록 시스템의 구성 요소들이 각자의 역할을 충분히 수행하면서도 유연하게 확장될 수 있어야 합니다. 
따라서, 생산자, 소비자, 브로커 및 파티션 같은 핵심 컴포넌트들이 규모에 맞게 확장 가능하도록 설계하는 것은 매우 중요합니다. 확장성 있는 설계를 통해 메시지 큐 시스템은 증가하는 수요를 감당하고, 장애 상황에서도 안정적으로 운영할 수 있습니다.

1. 생산자 확장 전략
2. 소비자 그룹 확장 및 리밸런싱 메커니즘
3. 브로커 노드의 확장과 장애 복구 계획
4. 파티션 확장과 데이터의 균등 분산
5. 데이터 복제와 일관성 유지
6. 메시지 전송 보장과 전달 방식의 최적화

#### 데이터 손실과 중복 방지를 위한 분산 메시지 큐의 메시지 전달 전략

분산 시스템에서 메시지를 소비자에게 전달하는 과정에서 발생할 수 있는 데이터 손실, 중복, 지연 등을 어떻게 다루는지가 시스템의 안정성과 효율성에 큰 영향을 미칩니다. 
각기 다른 요구사항을 가진 애플리케이션을 위해 다양한 메시지 전달 방식이 존재하며, 이 방식들은 각기 다른 수준의 보장과 특성을 제공합니다.

1. 최대 한 번(at-most-once) 전달 방식: 실패 시 재시도 없이 메시지를 한 번만 전송
2. 최소 한 번(at-least-once) 전달 방식: 메시지 손실을 방지하기 위해 재시도하는 방식
3. 정확히 한 번(exactly-once) 전달 방식: 데이터 중복과 손실을 모두 방지하는 고급 전달 방식

#### 고급 기능

분산 메시지 큐 시스템에서 고급 기능들은 메시지 전송 및 관리의 복잡한 요구 사항을 해결하기 위해 필수적입니다. 
이들 기능은 메시지 필터링, 지연 전송, 예약 전송 등으로 구성되며, 특히 메시지의 특정 조건에 따른 처리, 정확한 전송 타이밍 조정 등 복잡한 비즈니스 로직을 효율적으로 수행할 수 있게 합니다.

1. 필요한 메시지 선별을 위한 메시지 필터링 전략
2. 태그를 이용한 효율적인 메시지 필터링 방식
3. 시간 지연 후 메시지 전송을 위한 지연 전송 기능
4. 정해진 시간에 메시지를 전송하는 예약 전송 기능
5. 메시지 지연 전송과 예약 전송을 지원하는 임시 저장소 및 타이밍 조정 메커니즘

### 네 번째 단계: 마무리

이 장에서는 데이터 스트리밍 플랫폼의 고급 기능을 지원하는 분산 메시지 큐 시스템 설계의 다양한 개념을 설명했습니다. 
특히, 이러한 시스템을 효율적으로 운영하고 관리하는 데 필요한 프로토콜과 각종 기술적인 고려 사항들을 소개하여, 실제 시스템 설계 시 발생할 수 있는 문제를 해결하는 방법을 제시했습니다.

1. 프로토콜(protocol)의 정의와 필요성
2. 메시지 재소비(retry consumption) 전략
3. 이력 데이터 아카이브(historical data archive)와 로그 보존 메커니즘


## 면접 때 핵심적으로 고민해볼 원론적인 내용

분산 메시지 큐는 오늘날의 대규모 시스템에서 중요한 역할을 수행하는 핵심 구성 요소입니다. 
마이크로서비스 아키텍처와 같이 분산된 환경에서는 서비스 간 데이터 전송과 비동기 통신이 필수적이며, 이러한 작업을 효과적이고 안정적으로 처리하는 솔루션이 필요합니다. 
분산 메시지 큐는 대규모 트래픽 처리, 서비스 간 결합도 감소, 신뢰성 있는 메시지 전달 등 다양한 요구사항을 충족시킬 수 있는 기능을 제공합니다. 
시스템이 확장되고, 장애 복구 및 고가용성이 중요한 환경에서 분산 메시지 큐는 필수적인 인프라로 자리 잡고 있습니다.

1. 확장성 (Scalability): 대규모 트래픽을 처리할 수 있는 확장성을 제공하는가?
 - `파티셔닝 (Partitioning)`, `컨슈머 그룹 (Consumer Group)`, `분산 파일 시스템`
2. 내구성 및 신뢰성 (Durability and Reliability): 메시지가 손실되지 않고 저장되고 전달될 수 있도록 내구성이 보장되는가?
 - `쓰기 우선 로그 (Write-Ahead Log)`, `데이터 복제 (Replication)`, `ACK 설정`
3. 전달 보장 (Delivery Guarantees): 최소 한 번, 최대 한 번, 정확히 한 번 등의 전달 보장 방식이 유연하게 제공되는가?
 - `At-Least-Once`, `At-Most-Once`, `Exactly-Once (Kafka Streams)`
4. 비동기 처리 (Asynchronous Processing): 생산자와 소비자 간 비동기 통신을 지원해 서비스 간 결합도를 낮추고 효율성을 높이는가?
 - `프로듀서-컨슈머 모델`, `퓨처 (Future) 패턴 및 콜백 (Callback)`, `오프셋 관리`
5. 고급 기능 (Advanced Features): 지연 전송, 예약 전송, 필터링 등 복잡한 전송 요구사항을 지원하는 기능이 포함되어 있는가?
 - `지연 전송 (Delay Messaging)`, `예약 전송 (Scheduled Messaging)`, `메시지 필터링`
6. 오프셋 관리 및 데이터 보관 (Offset Management and Retention): 메시지 소비 상태를 추적하고 데이터 보관 정책을 통해 필요한 만큼 메시지를 보존하는가?
 - `오프셋 관리`, `데이터 보관 정책 (Retention Policy)`, `로그 압축 (Log Compaction)`
7. 장애 내성 및 높은 가용성 (Fault Tolerance and High Availability): 장애 상황에서도 데이터가 손실되지 않고 지속적으로 접근할 수 있도록 복제와 고가용성 메커니즘을 제공하는가?
 - `리더-팔로워 구조`, `ISR (In-Sync Replica)`, `ZooKeeper 또는 KRaft (Kafka Raft)`