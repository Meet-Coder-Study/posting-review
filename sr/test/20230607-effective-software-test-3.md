# 이펙티브 소프트웨어 테스팅 책을 읽고... (3)

- 어떤 입력 가능한 몇 가지 사례를 입력해보는 예시 기반 테스트를 작성하는 방식은 예상치 못한 값을 찾아내기 어렵다.
  (이미 내 머릿속은 정상 케이스에 대한 값들만 꽉차 있다.)

> - 명세 기반 테스트에서 이야기 했던 것처럼 테스트 프레임워크는 단지 실행하고, 결과물을 리포트 한다는 이야기를 했었다.
> - 테스트를 설계하는 작업은 개발자의 몫으로 창의성있는 다양한 케이스는 많은 시간을 투자하여 테스트 케이스를 작성해야 한다.

 * 이제부터는 [jqwik](https://jqwik.net) 라는 라이브러리를 통해 `테스트하고자 하는 속성을 표현`만 하고, `테스트 프레임워크가 구체적인 예시를 선택하여 테스트를 진행`해본다.

## 4. 계약 설계

- 사전 조건, 사후 조건, 불변식을 설계하는 방법
- 계약과 유효성 검사의 차이점에 대한 이해

테스트가 필요한 대상의 제약사항을 설계하려는 경우 세 가지 선택지가 있다.

1. 유효하지 않은 입력값을 선처리
2. 방어코드 작성
3. 명확한 계약(사전, 사후, 불변식)을 정의

---

### 명확한 계약

1. 메서드가 제대로 동작하도록 하는 `사전 조건`
2. 메서드가 산출물로 보장하는 `사후 조건`
3. 메서드의 사전, 사후 모두의 경우에서 유지되어야 하는 조건을 `불변식`


### 계약 변경과 리스코프 치환 법칙

이상적인 경우 클래스나 메서드의 계약을 정의한 후에 이를 변경하지 않는다.

하지만 실제로는 계약을 변경해야 하는 경우가 생긴다.

변경이 생기지 않도록 할 수는 없을지라도, 우리는 그 영향을 파악할 수는 있다.

변경으로 인한 영향을 파악하지 않는다면 시스템은 아마 의도하지 않게 동작할 것이다. 

계약 변경이 테스트 및 품질과 관련되어 있음을 보여준다.

> 변경사항에 대한 영향을 파악하는 가장 쉬운 방법은 변경 대상을 살펴펴보는 것보다 변경된 클래스를 사용하는 다른 모든 클래스를 살펴보는 것이다.

객체지향 언어에서는 계약 변경 시 영향도를 줄일 수 있는 방법으로 상속과 계약 관계를 이용할 수 있다.

시스템에 기대하는 동작을 깨뜨리지 않고 자식 클래스를 부모 클래스로 치환할 수 있는 개념을 리스코프 치환 법칙(Liskov Substitution Principle)이라고 한다.

- 추가로 상속을 피해야하는 경우에 대해 이펙티브자바 아이템 16. '상속보다는 컴포지션을 사용하라'를 참고하는 것도 좋다.


### 계약에 의한 설계가 테스트와 어떤 관련이 있는가?

명확한 계약(사전/사후 조건, 불변식)을 정의하는 경우 얻을 수 있는 것들

1. 단언문을 통해 제품 코드에서 버그를 일찍 발견할 수 있다.
2. 사전 조건, 사후조건, 불변식은 개발자에게 테스트 대상을 제공한다.
3. 명시적인 계약은 소비자의 삶을 편안하게 해준다.


### 유효성 검사와 계약 간의 차이

- 유효성 검사
  - 사용자로부터 들어올 수 있는 불량 데이터나 유효하지 않은 데이터가 시스템에 침투하지 않도록 하는 것
  - 잘못된 입력 값이 들어오는 경우, 관련된 메시지를 반환
  - 잘못된 일이 일어날 수 있음
- 계약
  - 클래스 간의 의사소통이 문제없이 일어나도록 하는 것
  - 계약 위반 시 프로그램은 중지
  - 잘못된 일이 일어나면 사고

두 영역이 다른 관점을 갖고 있으나, 맥락 상 같은 목표를 가질 수 있음

### 단언과 예외

- 라이브러리나 유틸리티 클래스에 대한 계약을 모델링 하는 경우, 예외
- 비즈니스 클래스와 클래스 간의 예약을 모델링하고 있으며, 값이 정제되었음을 확신하는 경우, 단언문
- 비즈니스 클래스를 모델링하지만 데이터가 정제되어 있는지 모르는 경우, 예외

유효성 검사 모델링을 선호하는 이유

1. 첫 번째 검사가 실패할 때 유효성 검사를 중지하려는 경우가 없다.
2. 많은 코드가 요구되는 복잡한 유효성 검사를 모델링 할 수 있다.

> 참고. 도메인 주도 설계의 명세 패턴

### 예외 vs 부드러운 반환값

예외를 던지지 않고, 메서드의 반환값을 정의하는 경우

- 일어나서는 안되는 동작이 발생하였고, 클라이언트가 그것을 어떻게 다루어야 할 지 모른다면, `예외`
- 클라이언트 메서드에 부드러운 값을 반환해서 클라이언트가 계속 작업할 수 있도록 할 수 있다면, `특정 값을 반환`


## 5. 속성 기반 테스트

속성 기반 테스트는 테스트할 대상의 속성을 정의하고, 그 속성을 만족하는 모든 입력값을 생성해내는 방식이다.

속성 기반 테스트에 대한 학습 테스트를 작성해보는 방식은 다음과 같다.

1. 파라미터의 구획(정상/실패 케이스)을 정의
2. 정상 케이스의 상세 구획(정상 범위 내에서도 결과 값이 달라지는 범주)의 정의
3. jqwik 라이브러리를 통해 @Property, @Provide 등을 정의하여 상세 구획에 대한 속성 기반 테스트를 작성

### jqwik 매개변수 랜덤 생성 작성

기본 파라미터 설정 참고

- [Default Parameter Generation](https://jqwik.net/docs/current/user-guide.html#default-parameter-generation)
- [Customized Parameter Generation](https://jqwik.net/docs/current/user-guide.html#customized-parameter-generation)

> 테스트의 전반적인 개념은 무작위로 값을 삽입해보는 것이다.

---

### jqwik 메서드 랜덤 수행 작성

- 무작위 행동을 일으키는 테스트 방법

테스트 케이스에서 몇 가지 동작을 테스트할 때, 다양한 동작을 정의하는 jqwik의 액션(Action) 사용법

- [Stateful Testing](https://jqwik.net/docs/current/user-guide.html#stateful-testing)

> 프로덕션 코드가 아니라, 테스트를 위해 메서드를 추가하는 것은 좋지 않은 생각이라 할 수 있지만, 이는 트레이드 오프 문제이다.

---

### 예시 기반 테스트 vs 속성 기반 테스트

지금까지 명세 기반 테스트 / 예시 기반 테스트, 구조적 테스트, 속성 기반 테스트 등등 설명하고 있다.

하나씩 필요한 것을 가져다 쓰면 된다는 식이 아니라, 책에서 이야기 하고 싶은 내용은 흐름을 생각하면서 필요한 테스트를 적절하게 사용하는 것이다.

흐름을 보면 개발시에는 우선 `명세 기반 테스트`와 `구조적 테스트`를 수행하고, 단순하고 자동화에 창의성이 필요하지 않은 `예시 기반 테스트`를 우선적으로 사용하고, 두 테스트 기법을 모두 적용해서 테스트 대상 프로그램을 훨씬 잘 파악하게 되면, 어떤 테스트 케이스가 `속성 기반 테스트`로 더 나을지 평가한다.

항상 속성 기반 테스트를 해야 하는 것은 아니다. 확신할 수 없는 경우 속성 기반 테스트를 사용한다.

---

- 속성 기반 테스트를 작성할 때의 유의사항
  - "내가 최대한 실제 동작과 가깝게 속성을 동작시키고 있는가?"
  - 테스트가 모든 구획을 같은 비율로 수행하고 있는가?

- 속성 기반 테스트의 장점
  - 매개변수 간에 상호작용을 테스트 해야하는 모든 경우의 수에 대한 테스트 케이스를 쉽게 작성할 수 있도록 돕는다.

- 속성 기반 테스트의 단점
  - 오픈소스 시스템에서 인기가 덜 한 이유가 있을 것이다.
  - 모든 경우의 수를 테스트한다는 것은 테스트 실행에 많은 시간이 소요된다는 것이다.

- 속성 기반 테스트의 일반적인 문제
  - 매우 비용이 많이 들거나 심지어 불가능한 데이터를 생성하도록 jqwik에게 요구하는 것
  - jqwik를 통해 경계값을 테스트하는 것 또한 개발자가 속성과 경계를 올바르게 표현하는 경우에만 잘 작동한다.
  - 테스트 대상 메서드에 전달할 입력 데이터가 가능한 모든 옵션 간에 균등하게 분포되어 있는지 확인하는 하였는가?

