# DBMS

## Intro

- DBMS의 아키텍처의 이해
  (Oracle, MySQL:InnoDB, PostgreSQL)
- 쿼리 실행 과정
- 옵티마이저와 통계정보
- 정리
- 피드백 추가

## DBMS 아키텍처

- DBMS 아키텍처, RDB의 내부적인 동작 모델을 이해하는 것이 목표이다.
	- `데이터 캐시` 또는 `워킹 메모리` 등의 `메모리 관련 구조`, `저장소 구조`
	- SQL의 퍼포먼스를 이해하기 위한 핵심 개념인 `실행 계획`과, 실행 계획을 만드는 `옵티마이저`

- DBMS가 `트레이드오프`의 균형을 위해 어떠한 노력을 하는지, 
  우리가 DBMS를 사용할 때는 **무엇을 우선**하고 **무엇을 버려야 하는지** 판단하는 기준을 세우는 것을 목표로 한다.

> **DBMS 아키텍처**

![DBMS 아키텍처](https://github.com/SeokRae/TIL/blob/master/database/sql_levelup/images/database.002.jpeg)

- **쿼리 평가 엔진(Query Evaluation Engine)**
	- 사용자로부터 입력 받은 **SQL구문**을 분석
	- 어떤 순서로 기억장치의 데이터에 접근할 지를 결정 **(실행 계획)**
	- 계획을 세우고 실행하는 DBMS의 **핵심 기능**을 담당하는 모듈

- **버퍼 매니저(Buffer Manager)**
	- 버퍼라는 **특별한 용도**로 사용하는 **메모리 영역을 확보하여 관리**하는 모듈
	- 디스크 용량 매니저와 함께 연동되어 작동

- **디스크 용량 매니저**
	- 어디에 어떻게 데이터를 저장할 지를 관리하는 모듈
	- 데이터의 읽고 쓰기를 제어

- **트랜잭션 매니저(Transaction Manager)와 락 매니저(Lock Manager)**
    - 여러 SQL 구문을 **동시에 실행하는 때**에 성능과 관련있는 메커니즘
	- 트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 역할을 하는 모듈
	
- **리커버리 매니저(Recovery Manager)**
	- 데이터를 **정기적으로 백업**하고, **문제가 일어났을 때 복구**하는 기능을 하는 모듈
	

> **쿼리 실행**을 돕는 **핵심모듈** 정리 

- DBMS는 SQL 쿼리를 실행하기 위해 **쿼리 평가 엔진**에서 `문법에 대한 검증`, 
  저장되어 있는 데이터를 기반으로 분석된 `통계 정보`를 기반으로 `다수의 실행 계획`을 세우고
  `가장 비용이 적은 실행 계획`으로 `데이터 조회를 실시`한다.
  
- **검색 쿼리**는 **버퍼 매니저**가 관리하는 **데이터 캐시**에 대한 개입을 통해 효율적인 검색을 처리하게 된다.
- **갱신 처리**에 대한 쿼리는 **버퍼 매니저**가 관리하는 **로그 버퍼**를 활용하여 쿼리를 **실행하는 시점**과 저장소에 **갱신하는 시점**에 차이가 있는 **비동기 처리**를 실시하게 된다.

---

### 성능적인 측면에서의 트레이드 오프 1

![메모리와 디스크에 저장하는 상황](https://github.com/SeokRae/TIL/blob/master/database/sql_levelup/images/database.003.jpeg)

- **기억 비용**에 대한 트레이드 오프
	- 기억 비용이란 데이터를 저장하는데 소모되는 비용을 뜻한다.

- **디스크**는 대용량 데이터를 **영속적으로 저장**하는데 메모리보다 좋지만, **데이터 접근 속도**는 메모리보다 떨어진다.
	- 많은 데이터를 영속적으로 저장하기 힘들다는 **트레이드 오프**가 발생한다.
	

> **버퍼 또는 캐시를 활용한 속도 향상**

- **버퍼 매니저**
	- `데이터를 어떻게, 어느 정도의 기간 동안 올릴지 관리하는 모듈`

- 성능 향상을 목적으로 데이터를 저장하는 메모리를 **버퍼(buffer)** 또는 **캐시(cache)** 라 한다.

- 데이터의 일부라도 **메모리에 올리는 이유**는 성능 향상을 위함이다.
	- `성능 향상`이란 쿼리를 실행했을 때 발생하는 **실행 속도(execution, fetching)** 를 빠르게 하는 것을 뜻한다.
	
- 자주 접근하는 데이터를 **메모리** 위에 올려둔다면, 
  같은 SQL 구문을 실행한다고 해도 **디스크**에서 데이터를 가져올 필요 없이 곧바로 **메모리**에서 읽어 빠르게 데이터를 검색할 수 있다.

- 디스크의 접근을 줄일 수 있다면 큰 폭의 성능 향상이 가능하다.
	- SQL 구문의 실행 시간 대부분을 **저장소 I/O**에 사용된다.

---

### 메모리 위에 있는 두 개의 버퍼

![버퍼 2가지](https://github.com/SeokRae/TIL/blob/master/database/sql_levelup/images/database.004.jpeg)

- **데이터 캐시(버퍼 캐시)**
	- 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역

- **로그 버퍼(Redo 로그 버퍼)**
	- **갱신 처리**를 위한 SQL 구문에 대해 디스크에 **변경 작업**을 수행하는 모듈
	- **갱신 처리**에 대한 성능을 높이기 위해,
	  해당 작업에 대한 **저장소 변경이 끝날 때**까지 기다리지 않기 위해 **사용자에게 끝났다**라는 통지를 한 뒤에 내부적으로 관련 처리를 계속 수행하는 것

![로그 버퍼 동작](https://github.com/SeokRae/TIL/blob/master/database/sql_levelup/images/database.005.jpeg)

- **상황**
	- 시스템이 **검색**에 비해 **갱신**이 많다면, 초기 설정을 그대로 사용해서는 성능이 제대로 나오지 않을 수 있다.
	- **로그 버퍼**의 크기를 늘려주는 **튜닝(최적화)** 이 필요하다.
	
### 성능적인 측면에서의 트레이드 오프 2

- **검색**과 **갱신** 중에서 어떤 것이 우선되어야 하는지에 대한 트레이드 오프
- **로그 버퍼**가 크게 잡혀있다면, **갱신 처리**와 관련되어 큰 부하가 걸린다는 것을 알 수 있다.
- 반대로 **데이터 캐시**가 크게 잡혀 있다면 **검색 처리**와 관련된 처리가 중심이라는 것을 알 수 있다.

### 추가적인 메모리 영역 '워킹 메모리'

- **워킹 메모리(Working Memory)**
	- DBMS는 2개의 버퍼 이외에도, 일반적으로 메모리 영역을 하나 더 가지고 있다.
	- 정렬 또는 해시 관련 처리에 사용되는 작업용 영역으로 **워킹 메모리**라는 것이 있다.
		- **정렬**은 `ORDER BY 구`, `집합 연산`, `윈도우 함수` 등의 기능을 사용할 때 실행된다.
		- **해시**는 주로 테이블 등의 결합에서 `해시 결합`이 사용되는 때 실행된다.
	- **이 영역이 중요한 이유**는 이 영역이 다루려는 데이터 양보다 작아 부족해지는 경우가 생기면 대부분의 DBMS가 저장소를 사용하기 때문이다.
		- DBMS가 저장소를 사용하게 되면 멈추거나 에러가 발생하는게 아니라 급격하게 느려지는 문제가 발생한다.

> **정리**

- DBMS는 SQL 구문을 읽어 알아서 처리하고 결과를 제공하는 **미들웨어**이다.
- 사용자는 데이터가 있는 곳을 알 필요도 없고, 데이터에 접근하는 방법도 따로 생각하지 않아도 된다.

---

## 쿼리 실행 과정

![쿼리 처리 과정](https://github.com/SeokRae/TIL/blob/master/database/sql_levelup/images/database.006.jpeg)

> **파서(parser)**

- 해당 모듈은 구문 분석을 하는 역할을 한다.
- 사용자로 부터 입력 받은 **SQL 구문을 분석**(프로그래밍의 컴파일과 같은 역할)
- SQL 구문을 정형적인 형식으로 변환 (DBMS 내부에서 일어나는 후속 처리의 효율)

> **카탈로그 매니저(catalog manager)**

- 옵티마이저가 **실행 계획**을 세울 때 필요한 정보를 제공하는 모듈
- **카탈로그**란 DBMS에 내부 정보를 모아 놓은 테이블들로, 테이블 또는 인덱스의 통계 정보가 저장되어 있다.

- 따라서, 이러한 카탈로그 정보를 간단하게 **통계 정보**라고 부르기도 한다.

> **옵티마이저(optimizer)**

- 서류 심사를 통과한 쿼리에 대한 최적화
	- 최적화 대상은 데이터 접근법(실행 계획)

- **옵티마이저가 판단하는 기준**
	- **인덱스 유무**
	- **데이터 분산** 또는 **편향** 정도
	- DBMS **내부 매개변수** 등의 조건

- 위 기준을 고려하여 **선택 가능한 많은 실행 계획을 작성**, **비용을 연산**, **가장 낮은 비용을 가진 실행 계획을 선택**
- 실행 계획에 대한 경우의 수가 많이 나오는 경우 그 비용을 계산하고 비교하는 작업을 수행한다.

> **플랜 평가(plan evaluation)**

- 옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 그것을 받아 최적의 실행 결과를 선택하는 것
- 실행 계획이란 개발자가 읽을 수 있는 **계획서**이다.
- 성능이 좋지 않은 SQL 구문이 있는 경우 실행 계획을 읽고, 수정 방안등을 고려할 수 있다.

- 하나의 실행 계획을 선택하면, DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행한다.

---

## 옵티마이저와 통계 정보

- 위 내용이 DBMS가 쿼리를 읽어들여 실제로 데이터 접근을 수행할 때까지의 흐름이다.
- **데이터베이스의 사용자**로서는 **옵티마이저**를 잘 사용하는 것이 중요하다.
- **카탈로그 매니저**가 관리하는 통계 정보에 대해서는 **데이터베이스 엔지니어**가 항상 신경써줘야 한다.

> **옵티마이저가 최적의 플랜 선택을 하지 못하는 경우**

- 옵티마이저는 **통계 정보가 부족**한 경우 **최적의 플랜 선택을 할 수 없다.**

- **카탈로그**에 포함되어 있는 **통계 정보**
	- **각 테이블의 레코드 수**
	- **각 테이블의 필드 수와 필드 크기**
	- **필드의 카디널리티(값의 개수)**
	- **필드 값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)**
	- **필드 내부에 있는 NULL의 수**
	- **인덱스 정보**

- 위 정보 활용하여 옵티마이저는 실행 계획을 세운다.

- **문제가 발생하는 상황**
	- 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하는 않는 경우
	- 갱신 처리(INSERT, UPDATE, DELETE) 수행 시 카탈로그 정보가 갱신되지 않는 경우

- 옵티마이저는 오래된 정보를 바탕으로 실행 계획을 세우게 되면 잘못된 계획을 세울 수 밖에 없다.

---

### 최적의 실행 계획이 작성되기 위한 방법

- **통계 정보**는 **SQL 성능**에 있어서 굉장히 중요한 문제이다.

- 테이블의 데이터가 많이 바뀌면 **카탈로그의 통계 정보**도 함께 **갱신**해야 한다.
	- 이는 **데이터베이스 엔지니어** 사이의 상식이다.

- **통계 정보를 갱신하는 방법**
	- **수동**으로 갱신
	- **자동**으로 갱신
		- 데이터를 크게 갱신하는 배치 처리가 있는 경우 Job Net을 조합하여 통계 정보를 갱신
		- Oracle의 경우 정기적으로 통계 정보 갱신 작업(Job)이 수행
		- Microsoft SQL Server처럼 갱신 처리가 수행되는 시점에 자동으로 통계 정보를 갱신

- **통계 정보 갱신 작업**
	- 대상 테이블과 인덱스의 크기와 수에 따라서 몇분 에서 몇 시간이 소요되는, **실행 비용이 굉장히 높은 작업**이다.

- 최적의 플랜을 선택하기 위해 필요한 조건이므로 갱신 시점을 확실하게 검토해야 한다.
 

## 정리

- 개발자의 입장에서 DBMS의 옵티마이저에 대한 이해가 필요하다는 것을 확인
- 통계정보에 해당하는 정보들이 같은 쿼리라도 속도가 차이가 날 수 있다는 것을 확인
- 검색, 갱신 쿼리에 대한 튜닝이 필요한 경우 데이터 캐시, 로그 버퍼의 용량을 확인하고 조절해야 한다는 것을 확인
- 옵티마이저가 통계정보를 통해 실행계획을 선택하는 방법을 쿼리 수준에서 조절해가면서 상황마다 어떤 실행계획을 선택하는 것이 좋은지 실습으로 확인하도록 한다. 

## DBMS 내용 진행 시 필요한 추가 정보

- 불특정 다수가 읽을 수 있는 글이기 때문에 target을 명확하게 잡기
  
- 위 내용에 대한 매커니즘이 모든 데이터베이스에 적용되는가?
	- Oracle, [MySQL(InnoDB)](2021-07-24-db-mysql-architecture.md), PostgreSQL에 대한 아키텍처와 
	  적용되는 부분 확인하기
	
- 로그 버퍼
	- 스토리지 엔진에 따라 로그 버퍼의 동작 방식

- 쿼리에 대한 로그는 어디서 관리하는지?
	- Query Cache 
	- [Real MySQL] - 3.1.7 쿼리 캐시 p114
	- [MySQL Query Cache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html)
	- [Oracle Result Cache](https://docs.oracle.com/database/121/TGDBA/tune_result_cache.htm#TGDBA617)
