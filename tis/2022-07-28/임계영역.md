## 임계 영역(critical section)

### **임계 영역이란**

임계영역은 각 프로세스에서 공유 데이터를 조작하는 명령을 포함하는 코드 영역을 의미합니다. 즉 ,임계영역은 병렬 컴퓨팅에서 둘 이상의 스레드가 동시 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말합니다.

### **임계영역 안에서는**

임계 구역은 **지정된 시간**이 지난 후 종료됩니다. 때문에 어떤 스레드나 프로세스가 임계 구역에 들어가고자 한다면 **지정된 시간**만큼 대기해야 합니다. 즉, 한 번에 하나의 프로세스만 공유 데이터에 접근하기 위해서는 특정한 프로세스가 임계 영역을 수행 중이면 다른 프로세스는 자신의 임계 영역의 코드를 수행할 수 없어야 합니다.

### **임계 영역의 문제를 해결하기 위해서**

스레드가 공유자원의 배타적인 사용을 보장받기 위해서 임계 구역에 들어가거나 나올 때는 세마포어와 같은 문제를 해결하기 위한 동기화 매커니즘을 사용합니다.

### 코드의 구역

각 프로세스는 자신의 임계 구역에 진입하려면 진입 허가를 요청해야 합니다. 이런 요청을 구현한느 코드 부분을 입장 구역(entry section)이라 합니다. 입장 구역에서 기다리다 진입 허가가 나면 임계 구역에 들어갑니다.  임계 구역 이후에는 임계 구역을 빠져나왔음을 알리는 코드 부분인 퇴장 구역(exit scetion)이 있습니다. 퇴장 구역에서는 권한을 반납하게 됩니다. 또한 그 밖의 나머지 코드 부분들을 총칭하여 나머지 구역(remainder section)이라 합니다.

```
do {
      **entry section** <- 입장 영역
			critical section <- 임계 영역
      **exit scetion** <- ****퇴장 영역
      remainder section (non critical section)
}while (true)
```

## 임계 구역 문제

### 임계 구역 문제

임계 구역 문제는 임계 구역으로 지정되어야 할 코드 영역이 임계 구역으로 지정되지 않았을 때 발생할 수 있는 문제를 의미합니다.

### 문제 해결 조건

임계영역을 해결하기 위해서는 상호 배제, 한정 대기, 진행이라는 조건을 만족해야 합니다.

**상호 배제**

상호 배제 조건은 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 임계 영역에서 실행될 수 없다는 것을 의미합니다. 임계 영역에 들어가려고 시도하는 프로세스는 임계영역에 진입한 프로세스가 나올 때까지 보류되다가 권한을 부여받을 때, 임계영역에 들어가게 됩니다.


**한정 대기(Bounded Waiting)**

한정 대기 조건은 임의의 프로세스가 자신의 임계 영역에 진입 요청을 한 후 허가되기 전까지 다른 프로세스들이 자신의 임계 영역에 진입하는 횟수에는 한계가 있어야 한다는 걸 의미합니다. 어떤 프로세스도 임계 영역에 들어가는 것이 무한정 연기 되어서 기아상태와 교착상태가 발생하게 두면 안됩니다.

> 💡 다른 프로세스의 기아 상황(Starvation)을 방지하기 위해 한 번 임계 영역에 들어간 프로세스는 다음 번 임계 영역에 들어 갈 때 제한을 두어야 합니다.


**진행**

진행 조건은 임계 영역에서 실행되는 프로세스가 없는 상태에서 임계 영역으로 진입하려 하는 프로세스들이 있다면 잔류 영역에서 실행되지 않고 있는 프로세스들만 다음으로 진입할 수 있는 대상이 되며 이 선택은 무한하게 연기할 수 없어야 하는 걸 의미합니다. 즉, 임계 영역 바깥에 있는 프로세스가 다른 프로세스의 임계 영역 진입을 막아서는 안됩니다.

> 💡 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러개 있다면 어느 것을 들일지 적절히 결정해야 합니다.

### 임계영역에서 발생하는 문제를 해결하기 위한 방법

임계영역에서 발생하는 문제를 해결하기 위해서 멀티 스레드 동기화 기법을 사용할 수 있습니다. 대표적인 예로 locks 방식인 뮤텍스(mutex), 스핀락(spinlock)이 있고, wait-signal 방식인 세마포어(semaphore) 방식이 있습니다.

### locks 방식 : 뮤텍스(mutex), 스핀락(spinlock)

상호 배제가 되도록 만들어진 lock 변수를 활용합니다. lock을 소유한 스레드만이 임계 영역에 진입하게 되고, lock을 소유하지 않은 스레드는 대기합니다.

### 뮤택스

ReentrantLock 클래스를 활용해서 구현했습니다.

```java
public class SequenceGeneratorUsingReentrantLock extends SequenceGenerator {

    private ReentrantLock mutex = new ReentrantLock();

    @Override
    public int getNextSequence() {
        try {
            mutex.lock(); // entry section 입장 영역
            return super.getNextSequence(); // critical section 임계 영역
        } finally {
            mutex.unlock(); // exit section  퇴장 영역
        }
    }
}
```

### wait-signal 방식 : 세마포어(semaphore)

n개의 자원을 사용하려는 m개의 스레드의 원활한 관리를 제공합니다. 자원을 소유하지 못한 스레드는 대기(wait)하고 자원 사용을 마친 스레드는 알림(signal)을 보낸다.

### 세마포어

```java
public class SequenceGeneratorUsingSemaphore extends SequenceGenerator {

    private Semaphore mutex = new Semaphore(1);

    @Override
    public int getNextSequence() {
        try {
            mutex.acquire();
            return super.getNextSequence();
        } catch (InterruptedException e) {
            // exception handling code
            throw new RuntimeException();
        } finally {
            mutex.release();
        }
    }
}
```

## 입출금 문제

입출금 문제는 입금과 출금이 동시에 수행될 때 발생할 수 있는 문제로, 경쟁 상태에 관한 문제 중 하나입니다.

### 문제 상황

1000원이 들어있는 계좌에 대해 500원을 입금하는 작업과 500원을 출금하는 작업을 동시에 수행해야 하는 상황입니다.

**입금 프로세스**

```
...
잔액 = 잔액 + 500
...

```

**출금 프로세스**

```
...
잔액 = 잔액 - 500
...

```

이 때, 위 프로세스들에서 작업이 원자적으로 수행되지 않으면 일관성이 손상될 수 있습니다. 위 코드에서 잔액 처리부분은 각각 한 문장으로서 원자적으로 보이지만, 실제 컴파일 될 때는 아래와 같이 여러 명령어로 나뉘게 되어 원자성을 잃습니다.

**고급 언어**

```
잔액 = 잔액 + 500
```

**저급 언어**

```
레지스터 = 잔액
레지스터 = 레지스터 + 500
잔액 = 레지스터
```

### 입출금 문제의 해결 방법

공유 데이터의 일관성을 유지하기 위해 공유 데이터를 접근하는 코드 부분을 임계 구역으로 지정함으로 문제를 해결할 수 있습니다.
