# DBMS에서 하나의 구문을 처리 할 때 발생하는 트레이드 오프

해당 글은 하나의 구문을 처리할 때 성능을 높이는 데 중점을 뒀다. 
즉, 실행 계획 변화에 따른 성능의 차이를 확인하고, 그에 따른 버퍼 매니저의 설정에 따른 성능 차이도 지켜볼 수 있다.

> 💡 하나의 구문을 처리한 관점에서는 실행 계획과 버퍼 매니저가 어떻게 동작하는지 확인했다.

# DBMS 아키텍처 개요

## 아키텍처

![Untitled](images/Untitled.png)

1. 쿼리 평가 엔진
    - 쿼리 평가 엔진에서 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터를 접근할지 결정한다.
    > 💡 DBMS는 쿼리 평가 엔진에서 실행 계획(쿼리 평가 엔진에서 결정되는 계획)을 토대로 접근 메서드(실행 계획을 기반으로 데이터를 접근하는 방법)를 실행한다.
2. 버퍼 매니저
    - 버퍼 매니저에서 버퍼 메모리 영역을 관리한다.
    > 💡 DBMS에서 버퍼 매니저는 디스크 용량 매니저와 함께 연동되어 작동한다.
3. 디스크 용량 매니저
    - 디스크 용량 매니저에서 어디에 어떻게 데이터를 저장할지 관리하며, 데이터의 읽고 쓰기를 제어한다.
5. 리커버리 매니저
    - 리커버리 매니저에서 데이터를 정기적으로 백업하고 문제가 일어났을 때 복구해주는 기능을 수행한다.


# DBMS와 버퍼

DBMS를 운용하는 비용과 메모리는 한정된 희소자원이기 때문에 버퍼에서 데이터 처리와 관련된 트레이드 오프가 발생한다.

## DBMS와 기억장치 관계

시스템의 데이터베이스 내부 데이터를 모두 메모리에(1차 기억장치) 올리는 것은 불가능하기 때문에 자주 접근하는 데이터를 메모리에 저장하고, 그 외에는 하드디스크(2차 기억장치)에 저장한다. 
여기에서 데이터를 영속적으로 저장하기 위해서는 속도를 잃고, 속도를 얻고자 하면 데이터를 영속적으로 저장하기 힘들기 때문에 영속성과 속도 사이에서 트레이드 오프가 발생한다. 

### 버퍼를 활용한 속도 향상

버퍼는 메모리에 데이터를 올려 디스크 접근을 줄여주는 완충제 역할을 하고, 캐시는 사용자와 저장소 사이에서 데이터 전송 지연을 완화시켜준다. 
이러한 버퍼와 캐시를 관리하는 것이 버퍼 매니저이기 때문에 성능에 굉장이 중요한 영향을 끼친다.

![Untitled](images/Untitled%201.png)

## 메모리 위에 있는 두 개의 버퍼

DBMS가 데이터를 유지하기 위해 사용하는 메모리는 데이터 캐시와 로그 버퍼이다. 
대부분의 DBMS는 이러한 두 개의 역할을 하는 메모리 영역을 가지고 있고, 용도에 따라 크기를 변경할 수 있다.

### 데이터 캐시

데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역이고, 질의를 처리한다. 

- 캐시에 데이터가 존재한다면 디스크에 접근하지 않기 때문에 응답속도가 빠르다.
- 반면에 캐시에 데이터가 존재하지 않는다면 저장소에서 데이터를 찾아야 하기 때문에 응답속도가 매우 늦다.

### 로그 버퍼

로그 버퍼는 갱신처리와 관련되어 있다. 갱신 요청이 들어오면 로그 버퍼에 변경 정보를 보내고, 이 후 디스크 변경을 수행한다.

![Untitled](images/Untitled%202.png)

> 💡 SQL 구문 실행과 저장소 갱신을 분리(비동기 처리)해 DBMS의 SQL 구문 실행 속도를 높인다. 
> 갱신처리를 바로 실행한다면 DBMS에 다른 요청은 저장소 안의 데이터가 변경이 끝날 때까지 대기해야하는 상황이 오기 때문에 갱신처리는 비동기로 설정되어 있다.

## 메모리의 성질이 초래하는 트레이드 오프

메모리 관점에 트레이드 오프를 생각할 때 비용과 휘발성 등 메모리 단점들을 고려해야 한다.

### 휘발성의 문제점

1. 영속적이지 않는다는 단점으로 인해 데이터의 부정합이 발생한다. 
2. 결과적으로 로그 버퍼 안 데이터를 비동기로 처리하기 때문에 데이터가 로그 파일에 반영하기 전에 장애가 발생하면 복구가 불가능하다.

### 휘발성 문제 해결을 위한 영속화

그래서 일반적인 DBMS는 커밋 시점에 반드시 갱신 정보를 로그 파일에 작성함으로 장애가 발생해도 정합성을 유지할 수 있게 한다. 
하지만 커밋을 통해 디스크에 데이터를 동기화해 처리하기 때문에 지연이 발생하기 때문에 정합성과 성능 사이의 트레이드 오프가 발생한다. 

### 참고 : DBMS에서 커밋 시간을 줄이기 위해 적용한 방법

1. 그룹 커밋을 통한 성능 향상
2. 지속성을 포기하고 비동기 처리 사용

> 💡 성능을 위해서 로그 버퍼에 로그 레코드를 모았다가 블록 단위로 로그 파일에 출력한다.
>> 참고 : [NAVER D2](https://d2.naver.com/helloworld/407507)

## 시스템 특성에 따른 트레이드 오프

![Untitled](images/Untitled%203.png)

### 데이터 캐시와 로그 버퍼의 크기

초기값으로 데이터 캐시가 로그버퍼의 크기가 많은 이유는 요청으로 들어오는 검색 쿼리가 갱신 쿼리보다 많기 때문이다. 
만약 갱신이 많다고 생각이 든다면 로그 버퍼를 늘려주는 튜닝을 고려해야 한다.

### 검색과 갱신 사이 트레이드 오프

질의를 처리하는 데이터 캐시와 갱신을 처리하는 로그 버퍼 사이의 트레이드 오프이다.

> 💡 데이터 캐시 > 로그 버퍼 :  질의 처리를 위한 DBMS 튜닝(또는 초기값)

> 💡 데이터 캐시 < 로그 버퍼 :  갱신 처리에 대한 부하를 줄이기 위한 튜닝

## 추가적인 메모리 영역 워킹 메모리

DBMS는 정렬과 해시 관련 처리에 사용되는 워킹 메모리가 존재한다. 이 메모리 영역은 필요할 때 생성이 되고, 종료되면 해제되는 임시 영역이다. 
이 영역이 성능적으로 중요한 이유는 워킹 메모리 영역이 다루는 데이터 양보다 작으면 DBMS의 저장소를 사용하는 스왑 현상이 일어나 성능이 현저히 떨어진다.

### 메모리가 부족하면 생기는 일

DBMS는 워킹 메모리가 부족할 때, 곧바로 SQL 구문 처리를 중단할 수 있지만 중단하지 않고 처리를 유지한다. 그렇기 때문에 메모리가 부족해지는 순간에 느려진다.

## DBMS와 버퍼 정리

DBMS를 운용하는 비용과 메모리는 한정된 희소자원이기 때문에 버퍼에서 데이터 처리와 관련된 트레이드 오프가 발생한다.

- 영속성과 속도 사이의 트레이드 오프
- 버퍼의 크기와 비용에 따른 트레이드 오프
- 데이터 캐시와 로그 버퍼 사이의 용량 트레이드 오프(검색과 갱신 사이 트레이드 오프)
- 데이터 정합성과 성능 사이의 트레이드 오프

# DBMS와 실행 계획

## 데이터에 접근하는 방법은 어떻게 결정할까

RDB에서 데이터 접근 절차를 결정하는 모듈은 쿼리 평가 엔진이고, 쿼리 평가 모듈은 파서, 옵티마이저와 같은 여러 개의 서브 모듈로 구성되어 있다.

- 파서
    - 요청받은 SQL 구문이 올바른지 분석하고 SQL 구문을 정형적인 형식으로 변환하는 역할을 한다. (변환하면 DBMS에서 후속 처리가 효율적이다.)
- **옵티마이저**
    - 옵티마이저는 인덱스 유무, 데이터 분산, 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해 선택 가능한 많은 실행 계획을 작성하고(플랜 생성), 이들의 비용을 연산(비용 평가)해 가장 낮은 비용을 가진 실행 계획을 선택한다.
- **카탈로그 매니저**
    - DBMS의 내부 정보를 모은 통계 정보가 저장되어 있다.
- 플랜 평가
    - 플랜 평가는 옵티마이저에서 여러 실행 계획을 받아 최적의 실행 결과를 선택하는 역할을 한다.

## 옵티마이저와 통계 정보

저장소에서 갱신 처리를 할 때마다 카탈로그 정보가 갱신되지 않기 때문에 카탈로그 정보가 실제 테이블과 인덱스 정보와는 일치하지 않는 경우가 많다. 
그래서 옵티마이저는 과거 정보를 가지고 계획을 세우기 때문에 최적의 플랜이 선택되지 않는 경우가 많다.

## 최적의 실행 계획이 작성하게 되려면

카탈로그 통계 정보를 수동으로 갱신하거나, 정기적으로 정보 갱신 작업을 수행하는 경우, 그리고 갱신 처리가 수행되는 시점에 통계 정보를 갱신하는 방법이 있다. 
DBMS가 최적의 플랜을 선택하려면 필요한 조건이므로 갱신 시점을 확실하게 검토해야 한다.

### 카탈로그와 옵티마이저

저장소에서 갱신 처리를 할 때마다 카탈로그 정보가 갱신되지 않기 때문에 카탈로그 정보가 실제 테이블과 인덱스 정보와는 일치하지 않는 경우가 많아서 최적의 플랜이 선택되지 않는 경우가 많다. 
그래서 카탈로그 통계에 최신 정보가 저장되게 해야 한다.

> ⚠️ DBMS가 최적의 플랜을 선택하려면 필요한 조건이므로 갱신 시점을 확실하게 검토해야 한다.

### 결합과 옵티마이저

SQL 지연이 일어나는 경우는 대부분 결합과 관련되고, 결합을 사용하면 실행 계획이 상당히 복잡해지므로 옵티마이저에서 최적의 실행 계획을 세우기 어렵다. 
그래서 DBMS의 성능을 높이기 위해 결합 알고리즘과 테이블 접근 순서의 중요성을 알아야 한다.

## 실행 계획이 SQL 구문이 성능을 결정

DBMS는 실행 계획을 바탕으로 데이터 접근을 수행하는데 데이터 양이 많은 테이블에 접근하거나 복잡한 SQL 구문을 실행하면 반응 지연이 발생하는 경우가 많다. 
지연이 발생하는 이유 중 하나는 통계 정보가 부족한 경우도 있지만, 최적의 경로가 설정되도 느린 경우도 있다. 
그리고 정보가 최신이라도 SQL 구문이 복잡하면 옵티마이저가 최적의 접근 경로를 선택하지 못할 수도 있다.

> SQL 지연이 일어나는 경우는 대부분 결합과 관련되고, 결합을 사용하면 실행 계획이 상당히 복잡해지므로 옵티마이저에서 최적의 실행 계획을 세우기 어렵다. 
> 그래서 DBMS의 성능을 높이기 위해 결합 알고리즘과 테이블 접근 순서의 중요성을 알아야 한다.

## 실행 계획의 중요성

최근 옵티마이저는 꽤 우수하지만 완벽한 것은 아니다. 그래서 힌트 구를 사용해 실행 계획을 수동으로 변경하면, 
옵티마이저에게 강제적으로 명령해 사용자가 원하는 실행 계획을 설정할 수 있다. 

- SQL 구문과 그런 SQL 구문들이 어떠한 접근 경로로 데이터를 검색하는지 알아야 한다.
- SQL 구문을 작성할 때 효율적으로 테이블을 설정해야 하고, SQL 구문이 어떤 실행 계획이 나올지 예측할 수 있어야 한다.

## 정리

- DBMS에서 영속성과 속도 사이에서 트레이드 오프
    - 메모리와 하드디스크 간의 트레이드 오프
- DBMS에서 버퍼의 크기와 비용에 따른 트레이드 오프
    - 기역비용에 의한 트레이드 오프
- DBMS에서 정합성과 성능 사이의 트레이드 오프
    - 갱신처리를 비동기처리할지 동기 처리할지의 트레이드 오프
- 질의를 처리하는 데이터 캐시와 갱신을 처리하는 로그 버퍼 사이의 트레이드 오프
    - 데이터 캐시와 로그 버퍼 사이의 트레이드 오프
