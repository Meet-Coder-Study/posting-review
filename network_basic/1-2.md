# CHAPTER 01 웹브라우저가 메시지를 만든다. - 下

## 웹 브라우저의 내부 탐험

---

1\.  HTTP 리퀘스트 메시지를 작성한다.   

_2\.  웹 서버의 IP 주소를 DNS 서버에 조회한다._

_3\.  전 세계의 DNS 서버가 연대한다._

_4\.  프로토콜 스택에 메시지 송신을 의뢰한다._


---


## 2\.  웹 서버의 IP 주소를 DNS 서버에 조회한다.

### (1) 도메인명과 IP 주소를 구분하여 사용하는 이유

브라우저가 HTTP 메시지를 만들면 이를 OS에 의뢰하여 액세스 대상에게 송신한다. __브라우저는 메시지를 네트워크에 송출하는 기능이 없으므로 OS에 의뢰하여 송신하는 것이다.__ 이때, URL에 포함된 서버의 도메인명이 어떤 IP인지 조사하는 과정이 필요하다. 

IP를 직접 사용하지 않고 도메인을 사용하는 이유는 다음과 같다.
1. 편의성 측면 : 문자로된 도메인이 더 기억하기 쉽다.
2. 효율성 측면 : IP주소는 32비트, 즉 4바이트이지만 도메인은 최대 255바이트까지 될 수 있다. 

기술의 발전에 따라 라우터의 속도는 빨라졌지만, 그에 못지 않게 데이터의 양도 증가하였다. 라우터의 속도에는 한계가 있기 때문에 굳이 더 무거운 도메인을 사용하는 것은 현명하지 않다.
   
### (2). DNS 서버에서 아이피를 조사

IP를 조사하기 위해서는 DNS 서버에 "이 도메인에 해당하는 아이피를 알려달라"고 요청하게 된다. DNS 서버에는 전세계의 모든 IP와 도메인 정보들이 담겨 있다. 따라서 DNS 서버는 요청이 오면 해당되는 IP를 응답한다.(반대도 마찬가지) 이때 DNS 서버에 클라이언트 역할을 하는 것을 **DNS 리졸버**(또는 리졸버)라고 한다. 

*DNS 리졸버란?*
- DNS 서버의 클라이언트 역할
- Socket 라이브러리에 속한 기능 중 하나.

*Socket 라이브러리*란?
- OS에 포함된 네트워크 기능을 애플리케이션에서 호출할 때 사용되는 라이브러리

정리하자면 웹 브라우저는 Socket 라이브러리의 `리졸버를 이용하여 DNS 서버에 IP를 조회한다.`


![]()
***
## 3\.  전 세계의 DNS 서버가 연대한다.
(DNS 서버에서 IP 주소를 찾는 과정에 대한 내용입니다.)

(개발과 관련성이 적어 생략하고 넘어갑니다.)

***

## 4\.  프로토콜 스택에 메시지 송신을 의뢰한다.

### (1) 데이터 송 · 수신 동작의 개요
요청메시지를 작성하고, ip주소를 조사했으면 이제 작성한 메시지를 송신해야 한다. 브라우저는 이번에도 **Socket 라이브러리를 호출하여 네트워크를 의뢰**한다. 하지만 **Socket 라이브러리도 네트워크에 대해 직접 데이터를 송 · 수신하는 기능이 없기 때문에** 이를 OS 내부에 있는 **프로토콜 스택**에 의뢰하게 된다.
```
브라우저 -> Socket 라이브러리 -> OS의 프로토콜 스택
```
*프로토콜 스택*이란?
* OS 내부에 내장된 네트워크 제어용 소프트웨어. '프로토콜 드라이버', 'TCP/IP 소프트웨어' 등으로도 부른다.

![]()

데이터를 송 · 수신 하는 컴퓨터 사이에는 데이터의 통로 같은 것이 있고, 이를 통해 데이터가 흐르게 된다. 이 통로를 `파이프`라고 하고 파이프의 양 끝의 데이터의 출입구 역할을 하는 것을 `소켓`이라고 한다. 이러한 소켓 통신은 다음과 같이 네 단계로 요약할 수 있다.

1. 소켓을 만든다.(소켓 작성 단계)
2. 서버측의 소켓에 파이프를 연결(접속 단계)
3. 데이터를 송 · 수신한다.(송 · 수신 단계)
4. 파이프를 분리하고 소켓을 말소한다.(연결 끊기 단계)

### (2) 소켓 작성 단계


```c
<디스크립터> = socket(<IPv4 사용>, <스트림형>, ...);

connect(<디스크립터>, <ip주소와 포트>, ...);

write(<디스크립터>, <송신데이터>, <송신데이터 길이>);

<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼>, ...);

close(<디스크립터>);
```

socket함수 호출을 통해 서버 측에서 먼저 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다린다. 소켓이 생성되면 `디스크립터`를 반환한다. 

### (3) 접속 단계
다음으로 애플리케이션은 connect함수를 통해 프로토콜 스택에 소켓 접속을 의뢰한다. connect를 할 때는 서버의 IP주소, 포트번호, 디스크립터 세 가지 값을 지정한다. 

IP주소를 통해 네트워크의 어느 컴퓨터인가(정확히 말하자면 네트워크용 하드웨어)를 식별하고, 포트를 통해 해당 컴퓨터의 어느 어플리케이션인가를 식별한다.

다만 디스크립터는 서버를 구분하기 위한 것이 아니라, 클라이언트 측에서 어플리케이션이 구분하기 위한 것이다.

예를 들어 한 컴퓨터에서 브라우저 창을 2개 띄워 각각 다른 사이트에 접속했다면, 해당 컴퓨터에는 두 개의 소켓이 생성되는데
이 때 어플리케이션에서(여기서는 브라우저) 어떤 소켓이 어떤 서버와 연결되었는지 구분하기 위해 사용 하는 것이다. 

### (4) 송 · 수신 단계
브라우저에서 작성한 송신 데이터(요청 메시지)를 메모리에 준비하고 write함수를 호출한다. 그러면 프로토콜 스택을 통해 앞서 연결한 소켓에 데이터를 쏟아 붓게 된다.

송신이 끝나면 이에 대한 응답 메시지를 수신하게 된다. 마찬가지로 read함수를 통해 프로토콜 스택에 수신동작을 의뢰하게 된다. 이때 수신한 응답 메시지는 read가 받아 `수신 버퍼`라는 메모리에 저장한다. 

*수신 버퍼*란?
* 어플리케이션 내부에 마련된 메모리 영역. read를 통해 데이터를 수신하면 이를 저장하고 있다가 애플리케이션에 건내줌.

### (5) 접속 종료 단계 
데이터 수신이 완료 되면 서버측에서 연결 끊기 동작을 실행한다.(어플리케이션에 따라 클라이언트에서 먼저 끊기도 함) 그러면 이것이 클라이언트측에 전달되어 클라이언트에서도 close를 호출하여 연결을 종료한다.

HTTP의 특징인 stateless
* 한번의 요청마다 접속과 접속끊기를 반복함.
* 장점은 각각의 요청이 독립적.
* 단점은 같은 서버에서 복수의 데이터를 주고 받을 때 비효율적.