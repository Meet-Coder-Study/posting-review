# CHAPTER 02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다. - 下

## 프로토콜 스택과 LAN 어댑터의 탐험



---

CHAPTER 01 웹브라우저 -> `CHAPTER 02 프로토콜 스택 & LAN 어댑터`

---
1\. 소켓을 작성한다

2\. 서버에 접속한다

`3. 데이터를 송 · 수신한다`

`4. 서버에서 연결을 끊어 소켓을 말소한다`

---

## 3. 데이터를 송 · 수신한다

### (4). 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.

* ACK번호에 대해 다시 설명하자면, `수신측에서 몇 번째 바이트까지 수신했는지`를 TCP헤더에 기록하여 전달하는 것. 패킷을 잘 전달하고 있는지 확인하는 용도로 쓰인다.
* 타임 아웃 : `송신 측에서 ACK 번호가 돌아오는 것을 기다리는 시간.`
* 네트워크에 정체가 발생하면 **ACK번호가 돌아오는 것이 지연되므로 타임아웃을 길게 설정**해야 함. 그렇지 않으면 ACK번호가 돌아오기 전에 다시 보내야 하는 상황이 발생.
* 반대로 **타임아웃이 너무 길면 패킷을 대기하는 시간이 너무 길어지게 되어** 동작이 송신 과정이 지연 됨.
* 따라서 타임아웃은 너무 짧지도 길지도 않은 적절한 값을 설정해야 한다. 하지만 이를 판단하기는 쉽지 않다.
* TCP에서는 타임아웃을 **동적으로 변경**하는 방법을 취하고 있다. 데이터 송신 동작에서 ACK번호를 수신하는 시간을 기록하여 이 시간이 길어지면 타임아웃을 늘리고, 짧아지면 타임아웃을 줄인다.
  
### (5). 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.

![](https://raw.githubusercontent.com/Blog-Posting/posting-review/32a7053fcf3ccaf76c981df912b17100157ca7bd/network_basic/img/2/sliding_window.png)

* 송신 측에서 한 개의 패킷을 보내고 나서 아무것도 하지 않고 ACK 번호를 기다리는 것은 시간낭비이다.
* 따라서 패킷을 보내고 **ACK 번호를 기다리는 동안 연속해서 패킷을 보냄**으로써 시간을 아낄 수 있는데, 이를 `윈도우 제어 방식(Sliding Window)`이라고 한다.
* 그렇다고 해서 송신측에서 무작정 패킷을 보낸다면 수신측에서 데이터를 우선적으로 저장하는 수신 버퍼가 초과하게 될 것이다. 수신 버퍼는 초과하게 되면 그 데이터는 소멸하게 된다.
* 이를 방지하기 위해서 **수신 측에서는 수신 가능한 데이터의 양을 통지하고, 송신 측에서는 이 양에 맞게 데이터를 송신**한다.

### (6). 데이터 송수신 동작 정리
* 프로토콜 스택의 데이터 송신 동작
* 수신한 데이터 조각(패킷)과 TCP헤더를 조사하여 데이터가 올바르게 수신 되었는지 확인
* 문제가 없을 경우 ACK 번호를 반송. 
* 데이터 조각을 수신 버퍼에 일시 보관.
* 데이터 조각을 조립
* 수신 데이터를 어플리케이션이 지정한 메모리로 옮겨 기록 후 어플리케이션에 제어를 되돌려줌.

---

## 4. 서버에서 연결을 끊어 소켓을 말소한다

### (1). 데이터 송수신을 완료했을 때 연결을 끊는다.

* 어플리케이션이 데이터 송수신 단계가 끝났다고 판단하면 연결 끊기 단계로 들어간다.
* 어디에서 연결을 먼저 끊는지는 어플리케이션에 따라 다르지만, 보통 서버 측에서 리퀘스트에 대한 응답을 보내고 연결을 끊게 된다.
* 연결 끊기 단계에 돌입하면 먼저 연결을 끊는 쪽에서 **TCP 헤더에 FIN을 1로 설정함으로써 연결 끊는다는 사실 전달**.
* 수신 측에서 ACK 번호를 반송하고, **마찬가지로 TCP헤더에 FIN을 1로 설정 하여 다시 전달**.
* 연결을 끊는 쪽에서 마지막으로 ACK를 반송함으로써 종료.

![](https://raw.githubusercontent.com/Blog-Posting/posting-review/32a7053fcf3ccaf76c981df912b17100157ca7bd/network_basic/img/2/tcp_fin.png)

### (2). 소켓을 말소한다.

* 연결을 끊고 나면 더이상 소켓을 이용하여 서버와 통신할 수 없게되므로 소켓은 필요 없어지게 된다.
* 하지만 바로 소켓을 말소하지 않고 잠시 기다린 후 소켓을 말소한다.
* 이는 오동작을 막기 위한 것으로, 오동작이 일어나는 이유는 다양하다. 그 중 몇 가지로는 마지막 ACK 번호가 돌아오지 않았을 경우, 타임 아웃으로 인해 패킷이 남아 있는 경우 등이 있다.
