# 회고

## 당근페이와서 느낀점

- 핀테크는 돈을 다루는 분야이다 보니 코드를 짤때 실수를 하지는 않았는지 계속 돌아보게 되고 걱정도 된다.
- 배포에 대한 자유가 많이 없다. 누가 배포하지 마라고는 안하지만 배포하기 위해서는 배포승인 요청 → 배포요청을 진행하는데 모두 다른 사람이 해주는 것이다보니 한 번 배포를 나갈때 많이 신경이 쓰인다.
- 문제가 생겼을 때 revert, hotfix 모두 배포승인요청&배포요청을 거치기 때문에 최대한 버그가 없는지 확인 또 확인을 하게되고 신경을 많이 쓰게 된다.
- 다른 서비스에서 우리 서비스를 연동하고 우리 서비스는 뱅크&카드사&PG사 등 많은 서비스들과 붙어있다.
- 연동하고 있는 뱅크, 카드사, PG사에 문제가 생기면 우리 서비스에 문제가 생기게되고 우리 서비스에 문제가 생기면 우리 서비스를 사용하고 있는 서비스들에 문제가 생기게 된다.
- 제약이 매우 많은 분야이다 보니 지금까지 경험하지 못한 케이스들을 많이 접하게 된다. 이런 케이스를 접할 때 마다 learn 하게 되는데 기술적 역량에 매우 도움이 되고 있다.
- 당근은 개개인에 대한 책임이 많이 주어진다. 개개인에 대한 책임이 많이 주어지게 되면 조직적으로 적은 인원으로 많은 효율을 낼 수 있지만 개개인이 부담을 많이 느낄 수도 있다. 개개인에 대한 책임은 주니어 입장에서 빠르게 프로가 될 수 있도록 하는 촉진제 역할도 하게 되는 것 같다.

## 책임

당근페이에 와서 느낀점은 개개인에게 주어지는 책임이 많다는 것이다. 처음에 당근페이에 왔을 때 인턴분이 실무코드를 개발해서 많이 놀랐다. 예전에 인턴했던 곳에서는 토이 프로젝트를 개발했고 실무 코드는 볼 수 있는 권한조차 막혀있었다. 여기서는 인턴도 실무코드를 개발하여 production에 배포하고 주니어도 하나의 큰 프로젝트를 담당하여 개발한다. 개개인에게 주어지는 역할과 책임이 크다는걸 느꼈다.

개개인에게 주어지는 역할과 책임이 크면 장단점이 분명하다. 단점은 책임이 크기에 부담감도 크고 부담감이 크게되면 심리적으로 불안한 감정이 유지될 수 있다. (사람마다 다르기는 하다) 장점은 빠르게 프로가 될 수 있다는 점이다. 프로라는게 주관적이긴 하지만 팀원들과 의사소통하며 필요한걸 얻어 담당하는 프로젝트를 성공적으로 이끌어 갈 수 있는 사람이라고 생각한다. 여기에는 기술적인 역량이 충분하다는걸 가정한다.

최근에 “클린 코더”라는 책을 읽었는데 여기에 프로는 어떠해야하는지에 대해 나온다.

> 프로가 아니면 세상 살기가 쉬워진다. 프로가 아니면 하는 일에 책임을 느낄 필요가 없으며 회사에 고스란히 책임을 떠넘겨도 된다. 프로가 아닌 사람이 잘못을 저지르면 회사가 뒤치다꺼리를 한다. 하지만 프로가 실수하면, 스스로 뒷감당을 해야 한다.
> 실수로 오류를 만들어 회사에 천만 원의 손해를 입혔다고 가정해보자. 프로가 아니라면 “그럴 수도 있지”라고 어깨를 한 번 으쓱하고 나서 아무 거리낌없이 다음 모듈 작업을 진행한다. 반면 프로라면 회사에 천만 원 손해 배상을 한다.

> 프로라면 한 명도 빠짐없이 오류에 책임을 져야 한다. 오류가 명백하지 않더라도 상황이 어떻게 돌아가는지 밝혀야 한다. 프로가 되겠다는 포부를 가지고 있다면, 우선 사과하는 법을 익혀야 한다. 사과는 필수요소지만 그것만으로는 충분하지 않다. 같은 오류를 반복하면 안 된다. 경력을 쌓아가면서 오류를 만드는 비율을 급격히 떨어뜨려 0에 가깝게 만들어야 한다. 0이 되지는 않지만 가능한 0에 가깝게 만드는게 당신 책임이다.

> 따라서 소프트웨어를 출시할 때는 QA가 문제를 찾지 못할 것이라고 어느 정도 자신할 수 있어야 한다. 코드에 결함이 있다는 걸 알면서도 QA에게 코드를 보내는 일을 매우 프로답지 못한 행동이다. 어떤 이들은 QA를 오류를 찾는 용도로 사용한다. 그런 사람들은 코드를 철저히 확인하지 않고 QA에게 보낸다. 그리고 오류를 찾아내 개발자에게 알려주는 QA에게 의존한다. 심지어 오류를 많이 찾는 순으로 QA에게 보상을 주는 회사도 있다. 이런 일이 얼마나 비싼 값을 치르는 일인지 신경쓰지 않는다. 일정을 망치고 개발팀의 모험심을 뿌리부터 갉아먹는 일이다.

> QA가 문제를 찾을 때마다, 더 나쁜 경우 사용자가 문제를 찾을 때마다, 개발자는 놀라움과 분함을 느껴야 마땅하며, 다시는 그런 일이 생기지 않도록 마음을 다져야 한다.

> 코드가 잘 돌아가는지 아닌지 알려면 어떻게 해야 할까? 간단하다 테스트하고 또 테스트해야한다. 이렇게도 테스트하고 저렇게도 테스트해야한다.
> 그렇게 하면 테스트에 너무 많은 시간이 걸리지 않을까 걱정될지도 모른다. 좋은 지적이다! 그러니까 테스트를 자동화해야 한다. 순식간에 실행할 수 있는 테스트를 만들고 가능한 자주 돌려야 한다.
> 얼마만큼의 코드를 자동화한 단위 테스트로 테스트해야 할까? 대답할 필요조차 없다. 모조리 다 해야 한다. 모.조.리!
> 100% 테스트 커버리지를 권장하냐고? 권장이 아니라 강력히 요구한다. 작성한 코드는 한 줄도 빠짐없이 전부 테스트해야 한다.


## 테스트

나는 테스트를 중요하게 생각한다. 당근페이 전 직장에서 1년간 이런 저런 방법들로 테스트하길 시도하고 적용하길 노력했으며 많은 방법들을 익혔다. 이제 테스트를 작성할 때 어떻게 mocking을 하고 jest의 어떤 함수를 써야하며 모듈들과 브라우저 내장 함수들을 어떻게 mocking해야하는지 바로 눈에 보인다. 특히 처음 들어왔을 때 피터와 테스트에 대해 1시간정도 1:1 이야기를 나눈적이 있었는 데 이때 머릿속에 있는 개념들이 많이 정리가 되었던 것 같다. 역시 뛰어난 개발자와 이야기하는 것 만큼 역량성장에 좋은건 없다.

A: 테스트코드 어떻게 작성해야할까요? 아직은 회의적인 입장이에요. 무엇을 어떻게 검증해야할지 잘 모르겠어요.

B: 유닛테스트를 할 때 순수함수와 비순수함수로 구분할 수 있는것 같아요.

### 순수함수

A: 순수함수는 테스트코드 짜는게 너무 명확해요. 테스트코드에서 output만 검증하면 되는 것 같아요. 순수함수는 명확하기에 문제가 안되는데 비순수함수를 어떻게 테스트해야할지 모르겠어요.

### 비순수함수

B: 프론트엔드에서 유틸함수 몇 개를 제외하면 대부분 비순수함수 같아요. 사이드 이펙트가 발생하는 부분이 너무 많아요. window 객체에 접근해서 조작하거나 api를 호출하거나 webApi를 사용하는 부분이 너무 많은 것 같아요. React Component도 Presentational Component를 제외하면 사이드 이펙트가 대부분 발생하는 것 같아요.

A: 비순수 함수는 output이 없는 함수, input이 같아도 output이 달라지는 함수로 나눌 수도 있을 것 같아요.

B: 먼저 output이 없는 함수를 이야기 해봐요.

A: 만약 localStorage에 저장하는 save 유틸함수를 테스트한다고 가정해봤어요. 저장이 잘 되면 output으로 'ok'를 내려주고 이를 테스트해보면 되지 않을까 생각이 되어요.

B: 그건 테스트코드를 잘못짠것 같아요. save를 호출했을 때 localStorage에 저장이 잘 되었는지 검증이 되었는지 검증해야 하는데 output이 'ok'인지를 검증하는 테스트코드 같아요.

A: 그럼 이런 방식은 어떤가요?

```tsx
save("key", "value");

expect(localStorage.getItem("key")).toBe("value");
```

B: 테스트 환경은 node 환경이지 브라우저 환경이 아니라서 localStorage가 존재하지 않아요. 그래서 그렇게 테스트하면 fail이 뜰꺼에요. 진짜 저장되었는지를 테스트하는게 아닌 localStorage를 mocking한 후에 localStorage.setItem의 첫 번째 두 번째 인자값에 'key', 'value'가 제대로 전달되어 호출되었는지를 검증해야해요.

```tsx
save("key", "value");

expect(localStorage.setItem).toHaveBeenCalledWith("key", "value");
```

A: api 함수 테스트코드를 보니 axios가 호출되는지를 검증하는게 아니라 axios의 response를 mocking하여 output을 테스트하던데 그건 왜 그런가요?

```tsx
beforeEach(() => {
  (cardRegistrationGateway.get as jest.Mock).mockResolvedValue({ data: mockResponse });
});

it('GET /card/brand', async () => {
  const response = await fetchCardBrand('12345678');

  expect(response).toEqual(mockResponse);
});
```

B: 사실 axios가 호출되는지도 검증하는게 맞긴한데 api 함수를 호출할 시 별다른 로직은 하나도 타지않기에 불필요한 테스트 같아서 response만 검증했어요. 실제로 api호출이 되면 안되니 axios는 당연히 mocking을 했구요. axios가 반환하는 응답값을 함수가 그대로 반환하는지만 테스트했어요. 만약 서버에서 날라오는 값을 조작하여 return을 한다면 그걸 테스트 해야겠죠? 그리고 이렇게 하면 이 함수의 response가 어떨지 다른 개발자가 쉽게 알 수도 있는 것 같아요.

A: 음.. api 호출하는 함수는 살짝 이해가 안가기는 하는데 앞에서 이야기한 내용을 정리해볼께요.

- 사이드 이펙트가 있는 외부 모듈을 mocking하고 테스트 대상 함수가 의도하는 행위를 하는데에 가장 직접적인 연관이 있는 함수가 호출(전달되는 파라미터) 되는지를 검증해요.
- API를 호출하는 함수같은 경우 의도된 포멧으로 응답값을 반환하는지를 검증해요.

### 컴포넌트 테스트

A: 다음으로 컴포넌트를 어떻게 테스트하는지 이야기 해보면 좋을 것 같아요. 로직을 가지고 있는 컴포넌트를 자식 컴포넌트로 가지고 있는 부모 컴포넌트는 무엇을 테스트해야 할까요?

B: 부모컴포넌트안에 있는 로직만 검증해야해요. 자식컴포넌트의 로직은 자식컴포넌트 테스트코드에서 검증해야해요. 그렇지 않으면 테스트코드가 중복으로 작성될꺼에요. page 같은 최상위 컴포넌트는 document title을 제대로 보여주고 있는지 자식 컴포넌트가 제대로 렌더링 되는지만 검증해요.

```tsx
const { container } = renderPage();

expect(container).toHaveTextContent("홈");
```

A: 복잡한 로직이 들어있거나 api 호출이 들어있는 컴포넌트는요?

B: 예로 들어 유저정보를 들고오는 컴포넌트가 있다고 했을때, api를 mocking한 후에 api에 error가 나면 에러 모달이 제대로 나오는지, api가 성공하면 컴포넌트가 유저정보를 제대로 보여주는지 테스트해요.

```tsx
context("유저정보 조회에서 api 에러가 나면", () => {
  given("error", () => ({
    response: {
      data: {
        message: "에러 메시지",
      },
    },
  }));

  it("에러 메시지가 보여야 한다.", () => {
    const { container } = renderComponent();

    expect(container).toHaveTextContent("에러 메시지");
  });
});

context("유저정보 조회에서 성공하면", () => {
  given("data", () => ({ name: "홍길동", phoneNumber: "111222333" }));

  it("유저정보가 보여야 한다.", () => {
    const { container } = renderComponent();

    expect(container).toHaveTextContent("홍길동");
  });
});
```

A: Presentational Component는 어떻게 테스트하나요?

B: jest-dom가 dom의 ComputedStyle 로 style 속성들을 들고와요. 이를 통해 component의 color가 'black'인지 'red'인지를 테스트할 수 있어요.

```tsx
context("color가 gray 이면", () => {
  given("color", () => "gray");

  it("gray button이 렌더링되어야 한다.", () => {
    renderActionButton();

    expect(screen.getByText("button")).toHaveStyle({
      color: theme.color.gray500,
      backgroundColor: theme.color.gray300,
    });
  });
});

context("color가 light-gray 이면", () => {
  given("color", () => "light-gray");

  it("light-gray button이 렌더링되어야 한다.", () => {
    renderActionButton();

    expect(screen.getByText("button")).toHaveStyle({
      color: theme.color.gray700,
      backgroundColor: "transparent",
    });
  });
});
```

A: 음.. 혹시 테스트하기 어려운 부분도 있나요? 보니까 커버리지 100% 인것 같던데 어떻게 100% 채울수 있었는지 궁금하네요

B: 3th-party lib 테스트가 진짜 어려워요. 이전에 chart.js 라이브러리를 사용하는 컴포넌트가 있었는데 chart.js는 canvas를 직접 건드리고 조작하는데 이런 방식은 검증하기 어려웠어요. 특히 콜백함수를 넣어줘야하는 경우에 그 콜백함수를 호출할 수 없는 케이스도 있어요. 이럴 때는 라이브러리 통째로 mocking하거나 해당 컴포넌트는 테스트를 하지 않도록 하고 있어요. 대신 외부라이브러리를 사용하는 곳은 커스텀 훅스로 캡슐화를 잘시켜야겠죠.

### 기타

utils, 컴포넌트, hooks를 테스트하는 것 만으로는 부족해서 e2e 테스트도 조금씩 작성하고 있다. 유닛테스트는 어쩔 수 없이 mocking이 많이 들어가기에 e2e로 진짜 유저가 사용하는 플로우로 모두 테스트해보고 싶어서이다. 내가 작성한 코드가 어디에서 오류가 발생하는게 너무 싫다ㅠ

나름 테스트에 자신이 있었는데 e2e 테스트에서 많이 좌절을 했었다. 여기에는 몇가지 테스트하기 힘든 이유가 존재 했기 때문이다.

1. 웹뷰기반 서비스들이 대부분이라 e2e 테스트에서 브릿지 함수들을 사용하지 못한다.
2. 로그인하여 토큰을 발급받아 실제 api를 찌르고 싶지만 ci 값으로 회원가입이 되어있기에 테스트를 위한 아이디를 발급받을수가 없다.
3. 로그인의 경우 account-webclient를 새로운 웹뷰로 띄워야 하는데 e2e 테스트 시나리오에서 새로운 창을 띄워서 로그인을 하는 방법이 쉽지 않다. (중간에 native 창도 띄워져야 한다.)

e2e 한정이긴 하지만 요즘들어 e2e 테스트도 매우 중요하다고 생각되어지고 중이라 고민이 많다.

현재는 모든 api를 mocking하여 나올수 있는 모든 케이스를 테스트하는게 최선이라 생각하여 진행중이다.

## 팀원과의 협업

내가 담당하는 프로젝트는 유닛테스트는 테스트 커버리지 100%로 항상 유지하려 애쓴다. 몇몇 테스트하기 힘든.. 외부 디펜던시가 강하게 결합된 훅스를 제외하면 전부 테스트를 하고있고 e2e도 api들을 모두 mocking 하기는 했지만 주요 유저시나리오는 테스트하고 있다.

그런데 다른 프로젝트도 개발하게 되었는데 이때 만약 테스트코드를 짜는게 맞을까? 라는 의문이 들었다. 지금까지의 나는 테스트코드에 많이 익숙했기에 쉽게 짤 수 있었지만 테스트코드 작성에 익숙하지 않은 팀원이 스팩이 변경되어 테스트코드가 있는 코드를 수정하게 되면 테스트도 깨지게 되고 테스트코드도 수정해야할 텐데 그게 팀원에게 많은 부담이 되지 않을까? 라는 생각이 들었기 때문이다. 그리고 테스트에 익숙하지 않은 상황에서는 테스트코드를 작성하는데 드는 리소스 만큼 테스트의 효과를 많이 보지 못한다. 왜냐하는 테스트코드를 작성하는데 드는 리소스가 매우 많이 들기 때문이다. 나도 경험을 해봤기 때문에 고민을 했던 것 같다. 그래서 유닛테스트는 하지않고 e2m(?) 테스트만 꼼꼼히 모두 작성하자라고 이야기를 했다. 하지만 최근에 실수를 하여 핫픽스를 했다는 점, 그리고 e2e 테스트에서는 웹뷰관련 테스트가 힘들다는 점으로 유닛테스트를 작성하는게 역시나 맞는 판단이지 않을까? 라는 생각이 스물스물 올라오고 있다.

## 많은 사연들이 있는 코드들

프로젝트에서 많은 디자인 개편이 이루어지는 개발을 진행중이다. 컴포넌트를 새로 만들고 조금 변형시키는 와중에 리팩터링을 하면 좋을만한 부분을 발견했지만 손대지 못했다. 최근에 핫픽스로 이어진 실수가 떠올라 손대기 무섭기도 했고 개발하는 프로젝트는 매우 많은 컨텍스트를 가지고 있는 프로젝트다 보니 내가 알지 못하는 컨텍스트가 있지는 않을까? 생각도 되었기 때문이다.

이번에 실수를 하면서 느낀게 그런 사연은 모두 사람이 아닌 테스트코드에 녹아 있어야 한다는걸 알았다. 전날 술을 많이 먹었다거나 오늘 몸이 너무 피로해서 매우 조그마한 기능만 수정하여 손으로 모두 테스트를 하지 않을 수도 있다. 프로답지 못한 행동이지만 사람은 완벽할 수는 없고 항상 꼼꼼할 수 없다. 그래서 프로세스를 만들고 테스트를 자동화를 해야한다. 내가 못하더라도 테스트가 검증하고, 테스트가 통과하면 나는 안심하고 배포할 수 있는.. 내가 작성한 코드가 다른 사연있는 코드를 건들지는 않았는지, 내가 미처 떠올리지 못했던 사연을 무시하지는 않았는지 걱정할 필요가 없다. 테스트에 그 사연들이 반영되어 있기 때문이다.

사실 이건 레거시 코드가 되어가는 매우 강한 신호임을 알고 있다. 코드에 사연이 있고 코드를 수정할 때 그 사연들을 알아야하는… 하지만 굳이 그 사연들을 알고싶지는 않은.. 

당근페이에 와서 회의가 진짜 많은 회사구나.. 라는걸 많이 느꼈었다. (지금은 잘 모르겠다 처음에는 유독 많았다) 그리고 이런 컨텍스트들을 모두 파악하고 대응하며 개발하다니.. 진짜 대단하다고 느꼈다.

> 부동산 파트너에서 결제 웹클라이언트를 열었을 때는 가상계좌이체만 보여야하고 “계약금 예치 완료를 위해 12,000원을 입금해주세요” 라고 커스텀하여 표시되어야 한다.

이런 컨텍스트가 내가 직접 휴대폰을 클릭하면서 확인하지 않아도 자동화된 테스트가 확인해야한다.

## 코드를 만질 때, 운영배포를 할 때 걱정하지 않도록

결제 웹클라이언트 ux 개편작업을 진행할때 과감하게 리팩토링하지 못하는 본인을 보면서 매우 좌절감을 느꼈다. 그리고 내가 알게 모르게 테스트에 많은 도움을 받고 있다는 사실도 알았다. 카드 웹클라이언트에서는 정말 과감하게 리팩터링을 한다. 폴더링을 바꾸고 컴포넌트명 함수명, 함수를 쪼개고 없애기까지 한다. 여기에는 내가 처음부터 개발을 담당했기에 모든 컨텍스트를 알고 있어서도 있겠지만 테스트로 인한 확신이 넘치기 때문이기도 하다. 새로운 기능 개발을 할 때도 연관없는 코드의 리팩터링을 시도때도 없이 진행한다. 처음에 잘 못 코드를 짰기 때문에 리팩터링 할께 많다고 생각할 수도 있지만 나는 처음부터 완벽한 코드는 짤 수 없다고 생각하기에 항상 조금씩 리팩터링을 한다. 

> “클린 코더”
> 유연하면서도 유지하기 쉬운 구조로 소프트웨어를 설계하는 데 필요한 원칙과 패턴을 소개한 글을 쉽게 찾아볼 수 있다. 프로 개발자는 이 원칙과 패턴을 마음에 새기고 그에 따라 소프트웨어를 작성한다. 하지만 간단한 요령도 있는데, 소프트웨어가 유연하길 바란다면 소프트웨어를 이리저리 구부려야 한다!
> 코드를 바꾸는 일은 언제 해야 할까? 항상 해야 한다! 모듈을 살펴볼 때마다 작고 가벼운 변화를 더해 구조를 개선해야 한다. 코드를 읽을 때마다 구조를 바꿔야 한다.
> 어떤 사람들은 이런 철학을 무자비한 리팩토링이라 부르지만, 나는 ‘보이 스카웃 규칙’이라 부른다. 보이 스카웃 규칙이란 모듈을 체크인할 때는 항상 체크아웃했을 때보다 깨끗해야 한다는 규칙이다.

> 이는 보통 사람들이 소프트웨어에 대해 생각하는 방식과 정반대다. 사람들은 동작 중인 소프트웨어를 계속 바꾸는 일이 위험하다고 생각한다. 아니다! 정말 위험한 일은 소프트웨어를 고정된 상태로 두는 일이다. 소프트웨어를 구부리지 않는다면, 정말 변화가 필요할 때 소프트웨어가 단단히 굳어있을 것이다.

> 왜 개발자들은 코드 바꾸기를 무서워할까? 코드를 망가트릴까 봐 겁이 나서다! 왜 코드를 망칠까 봐 겁이 날까? 테스트가 없기 때문이다.
