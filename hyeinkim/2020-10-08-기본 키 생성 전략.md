# JPA 기본 키 생성 전략

JPA가 제공하는 데이터베이스 기본 키 생성 전략에는 '**직접 할당하는 방법**'과 '**자동 생성하는 방법**' 두 가지가 있다.

- 직접 할당 : 기본 키를 애플리케이션에 직접 할당한다.
- 자동 생성 : 대리 키 사용 방식
   - `IDENTIFY` : 기본 키 생성을 데이터베이스에 위임한다.
   - `SEQUENCE` : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
   - `TABLE` : 키 생성 테이블을 사용한다. 마치 시퀀스처럼 사용하는 방법이다.

자동 생성 전략이 다양한 이유는 데이터베이스 벤더마다 지원하는 방식이 다르기 때문이다. 오라클은 시퀀스 오브젝트, MySQL은 AUTO_INCREMENT 방식으로 기본 키를 생성한다.

기본 키를 직접 할당하려면 `@Id`만 사용하면 되고 자동 생성 전략을 사용하려면 `@Id`에 `@GeneratedValue`를 추가하고 원하는 키 생성 전략을 선택하면 된다.

## 직접 할당

```java
@Entity
public class Board {

  @Id
  @Column(name = "id")
  private String id;
}
```

```java
Board board = new Board();
board.setId("id1"); // id를 set하지 않으면 예외 발생
em.persist(board);
```

기본 키 직접 할당전략은 em.persist()로 엔티티를 저장하기전에 애플리케이션에서 **기본 키를 직접 할당해야 한다**. **식별자 값 없이 저장하면 예외가 발생한다.**


## 자동 생성
### 1. IDENTIFY
- 기본 키 생성을 데이터베이스에 위임하는 전략
- MySQL, PostgreSQL, SQL Server, DB2

```java
@Entity
public class Board {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String title;

}
```

```java
@SpringBootTest
@Transactional
class BoardTest {
  
  @Autowired EntityManager em;
  
  @Rollback(false)
  @Test
  public void 기본키생성전략() {
    Board board = new Board();
    board.setTitle("기본키 자동 생성");
    em.persist(board);
    
    System.out.println("board.id = " + board.getId()); 
  }
}
```
```sql
Hibernate: -- em.persist()
    insert 
    into
        board
        (id, title) 
    values
        (null, ?) -- '기본키 자동 생성'
board.id = 1 -- System.out.println("board.id = " + board.getId());
```

IDENTIFY 전략은 데이터베이스에 값을 저장하고 나서야 기본 키가 생성된다. 이 말은 **INSERT한 후 기본 키 값을 조회할 수 있다**는 의미다. 

엔티티가 영속 상태가 되기 위해서는 식별자가 반드시 필요한데 IDENTIFY 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있다. 그래서 이 전략은 `em.persist()`를 호출한 즉시 INSERT 쿼리가 데이터베이스에 전달되서 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다. 


### 2. SEQUENCE
- 시퀀스 : 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트
- SEQUENCE 전략은 시퀀스를 사용해서 기본 키를 생성
- 오라클, PostgreSQL, DB2, H2

```java
@Entity
@SequenceGenerator(
  name = "BOARD_SEQ_GENERATOR",
  sequenceName = "BOARD_SEQ", // 매핑할 데이터베이스 시퀀스 이름
  initialValue = 1, allocationSize = 1
)
public class Board {

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "BOARD_SEQ_GENERATOR")
  private Long id;
}
```

```java
@SpringBootTest
@Transactional
class BoardTest {
  
  @Autowired EntityManager em;
  
  @Rollback(false)
  @Test
  public void 기본키생성전략() {
    Board board = new Board();
    board.setTitle("기본키 자동 생성");
    em.persist(board);
    
    System.out.println("board.id = " + board.getId()); 
  }
}
```
실행 코드는 똑같지만 SEQUENCE와 IDENTIFY 전략은 내부 동작 방식이 다르다. 


```sql
Hibernate: -- em.persist()
    call next value for board_seq  
board.id = 1 -- System.out.println("board.id = " + board.getId());
Hibernate: -- flush
    insert 
    into
        board
        (title, id) 
    values
        (?, ?) -- 1, '기본키 자동 생성'
```

IDENTIFY 전략은 `em.persist()`를 호출하는 순간 INSERT 쿼리를 DB에 보냈다. 하지만 SEQUENCE 전략은 INSERT 쿼리를 DB로 바로 보내지 않고 먼저 데이터베이스 시퀀스를 사용해 식별자를 조회한다. 조회한 식별자는 엔티티에 할당되고 영속성 컨텍스트에 저장된다. 그리고 플러시가 일어나면 엔티티를 데이터베이스에 저장한다. 이 시점에 INSERT 쿼리가 발생하는 것이다. **엔티티에 식별자가 할당되어 있기 때문에 쿼리 발생시 기본 키가 NULL이 아닌 식별자로 바인딩된다.**  


**@SequenceGenerator**
- `name` : 식별자 생성기 이름(필수)
- `sequenceName` : 데이터베이스에 등록되어 있는 시퀀스 이름
  - 기본값 : hibernate_sequence
- `initalValue` : DDL 생성 시에만 사용됨. 시퀀스 DDL을 생성할 때 처음 시작되는 수를 지정한다.
  - 기본값 : 1
- `allocationSize` : 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨)
  - 기본값 : 50

```sql
create sequence [sequenceName]
start with [initialValue] increment by [allocationSize]
``` 

### 3. TABLE
- 데이터베이스 시퀀스를 흉내내는 전략. 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만든다.

```java
@Entity
@TableGenerator(
  name = "BOARD_SEQ_GENERATOR",
  table = "MY_SEQUENCE",
  pkColumnValue = "BOARD_SEQ", allocationSize = 1
)
public class Board {

  @Id
  @GeneratedValue(strategy = GenerationType.TABLE, generator = "BOARD_SEQ_GENERATOR")
  private Long id;
}
```

```java
@SpringBootTest
@Transactional
class BoardTest {
  
  @Autowired EntityManager em;
  
  @Rollback(false)
  @Test
  public void 기본키생성전략() {
    Board board = new Board();
    board.setTitle("기본키 자동 생성");
    em.persist(board);
    
    System.out.println("board.id = " + board.getId()); 
  }
}
```

```sql
Hibernate: 
    insert into my_sequence(sequence_name, next_val) values ('BOARD_SEQ',0)
Hibernate: 
    select
        tbl.next_val 
    from
        my_sequence tbl 
    where
        tbl.sequence_name=? for update
            
Hibernate: 
    update
        my_sequence 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
board.id = 1
Hibernate: 
    insert 
    into
        board
        (title, id) 
    values
        (?, ?)
```

**@TableGenerator**
- `name` : 식별자 생성기 이름(필수)
- `table` : 키생성 테이블명
  - 기본값 : hibernate_sequences
- `pkColumnName` : 시퀀스 컬럼명
  - 기본값 : sequence_name
- `valueColumnName` : 시퀀스 값 컬럼명
  - 기본값 : next_val
- `pkColumnValue` : 키로 사용할 값 이름
  - 기본값 : 엔티티 이름
- `initialValue` : 초기 값. 마지막으로 생성된 값이 기준이다.
  - 기본값 : 0
- `allocationSize` : 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨)
  - 기본값 : 50
- `uniqueConstraints(DDL)` : 유니크 제약 조건을 정할 수 있다. 

```sql
create table MY_SEQUENCES (
  sequence_name varchar(255) not null, -- 시퀀스 이름
  next_val bigint, -- 시퀀스 값
  primary key (sequence_name)
)
```

### 4. AUTO
- 선택한 데이터베이스 방언에 따라 `IDENTIFY`, `SEQUENCE`, `TABLE` 전략 중 하나를 자동 선택함
  - 예) 오라클 : `SEQUENCE`
  - 예) MySQL : `IDENTIFY`
- `@GeneratedValue`의 기본값은 AUTO다 
  - `strategy = GenerationType.AUTO` 생략 가능

```java
@Entity
public class Board {
  @Id
  @GeneratedValue
  private Long id;

}
```

AUTO 전략의 장점은 **데이터베이스를 변경해도 코드를 수정할 필요가 없다**는 것이다. 그래서 개발 초기 단계 혹은 프로토타입 개발 시 (키 생성 전략이 확정 x) 편리하게 이용 가능하다. 

# 참고자료
- 자바 ORM 표준 JPA 프로그래밍
